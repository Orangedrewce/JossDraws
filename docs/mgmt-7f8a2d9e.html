<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>Admin | Review Link Generator</title>
    <link rel="preconnect" href="https://pciubbwphwpnptgawgok.supabase.co">
    <link rel="stylesheet" href="css/mgmt.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <main class="card">
        <div class="card-header">
            <h1>Admin Dashboard</h1>
            <p class="description">Manage review links, gallery content, and site settings</p>
        </div>

        <details class="recent-links" open>
            <summary class="section-summary" style="padding-bottom:0.5rem; margin-bottom:0.75rem;">
                <span>Review Link Generator</span>
                <span class="chevron">‚ñº</span>
            </summary>

        <form id="generatorForm">
            <label for="sourceSelect">Select Source Type</label>
            <select id="sourceSelect" name="source">
            </select>

            <button id="generateBtn" type="submit">
                Generate Link
            </button>
        </form>

        <div id="errorMessage" class="error-message is-hidden" role="alert" aria-live="assertive"></div>

        <div id="resultArea" class="is-hidden" role="status" aria-live="polite">
            <div class="result-label">üìß Send this link to your customer:</div>
            <div class="link-container">
                <input 
                    type="text" 
                    id="linkOutput" 
                    class="link-box" 
                    readonly 
                >
                <button 
                    id="copyBtn" 
                    class="copy-btn" 
                    type="button"
                >
                    Copy
                </button>
            </div>
            <div class="source-tag" id="sourceTag"></div>
        </div>
        </details>

        <!-- Performance Stats Removed (Redundant) -->

        <hr class="divider is-hidden" id="linksDivider">

        <div class="recent-links is-hidden" id="recentLinksContainer">
            <div class="recent-links-title-row">
                <button type="button" class="recent-links-title" id="recentLinksToggle" aria-expanded="false" aria-controls="recentLinks">
                    <span id="recentLinksTitle">üìã Recent Review Links</span>
                    <span class="expand-arrow collapsed" id="expandArrow">‚ñº</span>
                </button>
                <button type="button" class="filter-badge clear-filter is-hidden" id="clearFilterBtn" title="Clear filter">‚úñ Clear</button>
            </div>
            <div id="recentLinks" class="is-hidden">
                <p class="filter-hint">Tap a source name to filter by type</p>
                <div id="recentLinksList"></div>
                <div id="recentLinksSentinel" class="links-sentinel"></div>
            </div>
        </div>

        <div class="empty-state is-hidden" id="emptyState">
            <div class="empty-state-icon">üì≠</div>
            <div class="empty-state-text">No links generated yet</div>
        </div>

        <hr class="divider" id="galleryDivider">

        <details class="recent-links" id="gallerySection">
            <summary class="section-summary">
                <span>Gallery Manager</span>
                <span class="chevron">‚ñº</span>
            </summary>

            <div class="gallery-section-content">
                <p class="description" style="margin-bottom:1rem;">Add artwork to the website gallery. Paste a Google Drive share link and it will be auto-converted. <em>Drag items to cut in line and reorder.</em></p>

                <form id="galleryForm" class="gallery-form">
                    <label for="galleryUrl">Google Drive Image URL</label>
                    <input type="text" id="galleryUrl" placeholder="Paste Google Drive share link here..." autocomplete="off">
                    <div id="galleryUrlStatus" class="gallery-url-status is-hidden"></div>
                    <div id="galleryPreview" class="gallery-preview is-hidden"></div>

                    <label for="galleryTitle">Artwork Title <span class="text-danger">*</span></label>
                    <input type="text" id="galleryTitle" placeholder="e.g. Rough Waters" required>

                    <label for="galleryMedium">Medium (optional)</label>
                    <input type="text" id="galleryMedium" list="mediumOptions" placeholder="e.g. Digital, Canvas, Physical">
                    <datalist id="mediumOptions">
                        <option value="Digital">
                        <option value="Canvas">
                        <option value="Physical">
                        <option value="Mixed Media">
                    </datalist>

                    <label for="galleryYear">Year Created (optional)</label>
                    <input type="number" id="galleryYear" min="1900" max="2100" placeholder="e.g. 2024">

                    <div id="galleryCaptionPreview" class="gallery-caption-preview"></div>

                    <button type="submit" id="galleryAddBtn" class="gallery-add-btn">Add to Gallery</button>
                </form>

                <div id="galleryMessage" class="gallery-msg is-hidden" role="status" aria-live="polite"></div>

                <div class="gallery-items-list">
                    <div id="galleryCount" class="gallery-count"></div>
                    <div id="galleryList"><p class="text-muted-2" style="font-size:0.85rem;">Open this section to load gallery items...</p></div>
                </div>
            </div>
        </details>

        <hr class="divider" id="heroDivider">

        <details class="recent-links" id="heroSection">
            <summary class="section-summary">
                <span>Hero Slideshow Manager</span>
                <span class="chevron">‚ñº</span>
            </summary>

            <div class="gallery-section-content">
                <p class="description" style="margin-bottom:1rem;">Manage the banner images at the top of the landing page. A random active slide is shown to each visitor. Paste a Google Drive share link and it will be auto-converted. <em>Drag items to reorder.</em></p>

                <form id="heroForm" class="gallery-form">
                    <label for="heroUrl">Google Drive Image URL</label>
                    <input type="text" id="heroUrl" placeholder="Paste Google Drive share link here..." autocomplete="off">
                    <div id="heroUrlStatus" class="gallery-url-status is-hidden"></div>
                    <div id="heroPreview" class="gallery-preview is-hidden"></div>

                    <button type="submit" id="heroAddBtn" class="gallery-add-btn">Add Slide</button>
                </form>

                <div id="heroMessage" class="gallery-msg is-hidden" role="status" aria-live="polite"></div>

                <div class="gallery-items-list">
                    <div id="heroCount" class="gallery-count"></div>
                    <div id="heroList"><p class="text-muted-2" style="font-size:0.85rem;">Open this section to load hero slides...</p></div>
                </div>
            </div>
        </details>

        <hr class="divider" id="settingsDivider">

        <details class="recent-links" id="settingsSection">
            <summary class="section-summary">
                <span>Settings</span>
                <span class="chevron">‚ñº</span>
            </summary>
            <div class="gallery-section-content">
                <form class="gallery-form" onsubmit="return false;">
                    <label for="currentCodeInput">Current Admin Code</label>
                    <input type="password" id="currentCodeInput" placeholder="Current code" autocomplete="current-password">
                    <label for="newCodeInput">New Admin Code</label>
                    <input type="password" id="newCodeInput" placeholder="New code (min 4 characters)" autocomplete="new-password">
                    <label for="confirmCodeInput">Confirm New Code</label>
                    <input type="password" id="confirmCodeInput" placeholder="Re-enter new code" autocomplete="new-password">
                    <button type="button" id="changeCodeBtn" class="btn-warning">Change Admin Code</button>
                </form>
                <div id="changeCodeMessage" class="is-hidden gallery-msg" style="margin-top:0.75rem;"></div>
            </div>
        </details>
    </main>

    <script>
    (function () {
        'use strict';
        // ============================================
        // DEMO TRACE LOGGER
        // ============================================
        const Trace = (() => {
            let step = 0;

            function time() {
                return new Date().toISOString().split('T')[1].replace('Z', '');
            }

            function log(event, data = null) {
                step += 1;
                const id = String(step).padStart(2, '0');
                const prefix = `[${id} | ${time()}] ${event}`;
                if (data !== null && data !== undefined) {
                    console.log(prefix, data);
                } else {
                    console.log(prefix);
                }
            }

            function group(label) {
                console.group(`‚ñ∂ ${label}`);
            }

            function groupEnd() {
                console.groupEnd();
            }

            return { log, group, groupEnd };
        })();

        Trace.log('APP_INIT');

        // ============================================
        // AUTH LOCKOUT OVERLAY (no DOM replacement)
        // ============================================
        function showAuthLockout(message) {
            const existing = document.getElementById('auth-lockout');
            if (existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.id = 'auth-lockout';
            overlay.className = 'auth-screen auth-screen--danger auth-lockout';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', 'Access denied');

            const title = document.createElement('h2');
            title.textContent = 'Access Denied';

            const body = document.createElement('p');
            body.textContent = message || 'Invalid admin code.';

            overlay.append(title, body);
            document.body.appendChild(overlay);
        }

        function clearAuthLockout() {
            const existing = document.getElementById('auth-lockout');
            if (existing) existing.remove();
        }

        // ============================================
        // ACCESS GUARD (server-side verified)
        // ============================================
        // The admin code is sent to Postgres on every action and
        // verified against a bcrypt hash. Even if someone reads this
        // source code, they cannot do anything without the real code.
        // ============================================
        let adminCode = null;
        {
            Trace.group('ACCESS_GUARD');
            const MAX_ATTEMPTS = 3;
            for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
                const input = prompt('Enter admin code:');
                if (input === null) break;
                if (input && input.trim().length > 0) {
                    adminCode = input.trim();
                    break;
                }
            }

            if (!adminCode) {
                Trace.log('AUTH_NO_INPUT');
                Trace.groupEnd();
                showAuthLockout('No admin code provided.');
                throw new Error('Access denied');
            }

            Trace.log('AUTH_CODE_RECEIVED');
            Trace.groupEnd();
        }

        Trace.log('PAGE_LOADED');

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            SUPABASE_URL: 'https://pciubbwphwpnptgawgok.supabase.co',
            SUPABASE_KEY: 'sb_publishable_jz1pWpo7TDvURxQ8cqP06A_xc4ckSwv',
            SITE_URL: 'https://orangedrewce.github.io/JossDraws/review.html',
            MAX_RETRIES: 3,
            RETRY_DELAY: 1000
        };

        const DEFAULT_SOURCE_KEY = 'general';
        const SOURCES = {
            commission: { emoji: 'üé®', label: 'Commission' },
            etsy: { emoji: 'üõçÔ∏è', label: 'Etsy Order' },
            print: { emoji: 'üñ®Ô∏è', label: 'Art Print' },
            sticker: { emoji: 'üè∑Ô∏è', label: 'Sticker' },
            bookmark: { emoji: 'üîñ', label: 'Bookmark' },
            pet_portrait: { emoji: 'üêæ', label: 'Pet Portrait' },
            faceless_portrait: { emoji: 'üë§', label: 'Faceless Portrait' },
            coloring_book: { emoji: 'üñçÔ∏è', label: 'Coloring Book' },
            general: { emoji: 'üìã', label: 'General' }
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        // DOM Elements
        const elements = {
            form: document.getElementById('generatorForm'),
            btn: document.getElementById('generateBtn'),
            sourceSelect: document.getElementById('sourceSelect'),
            resultArea: document.getElementById('resultArea'),
            linkOutput: document.getElementById('linkOutput'),
            sourceTag: document.getElementById('sourceTag'),
            copyBtn: document.getElementById('copyBtn'),
            errorMessage: document.getElementById('errorMessage'),
            recentLinksContainer: document.getElementById('recentLinksContainer'),
            linksDivider: document.getElementById('linksDivider'),
            emptyState: document.getElementById('emptyState'),
            recentLinksToggle: document.getElementById('recentLinksToggle'),
            clearFilterBtn: document.getElementById('clearFilterBtn'),
            recentLinks: document.getElementById('recentLinks'),
            recentLinksList: document.getElementById('recentLinksList'),
            recentLinksSentinel: document.getElementById('recentLinksSentinel'),
            recentLinksTitle: document.getElementById('recentLinksTitle'),
            expandArrow: document.getElementById('expandArrow')
        };

        let db;
        try {
            db = supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_KEY);
            Trace.log('DB_CONNECTED');
        } catch (error) {
            console.error('Failed to initialize Supabase client:', error);
            Trace.log('DB_CONNECTION_FAILED', { message: error?.message || String(error) });
            showError('Failed to connect to database. Please refresh the page.');
            if (elements.btn) elements.btn.disabled = true;
        }
        
        const state = {
            filter: null,
            links: {
                expanded: false,
                pageSize: 20,
                offset: 0,
                hasMore: true,
                loading: false,
                queryKey: 0,
                observer: null
            }
        };

        // Delete confirmation state
        const DELETE_CONFIRM_MS = 3000;
        const pendingDeletes = new Map();

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        /**
         * Validates that a source value is non-empty and safe
         */
        function validateSource(source) {
            if (!source || typeof source !== 'string') {
                return { valid: false, error: 'Please select a valid source type' };
            }
            
            const trimmed = source.trim();
            if (trimmed.length === 0) {
                return { valid: false, error: 'Source cannot be empty' };
            }

            const key = trimmed.toLowerCase();
            if (!/^[a-z0-9_]+$/.test(key)) {
                return { valid: false, error: 'Invalid source type selected' };
            }

            if (!Object.prototype.hasOwnProperty.call(SOURCES, key)) {
                return { valid: false, error: 'Invalid source type selected' };
            }

            return { valid: true, value: key };
        }

        /**
         * Sanitizes text for display (prevents XSS)
         */
        function sanitizeText(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Sanitizes a value for use inside HTML attributes (prevents attribute-breakout XSS)
         */
        function sanitizeAttr(value) {
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function setHidden(el, hidden) {
            if (!el) return;
            el.classList.toggle('is-hidden', Boolean(hidden));
        }

        /**
         * Shows error message to user
         */
        let errorTimer = null;
        function showError(message) {
            if (errorTimer) clearTimeout(errorTimer);
            elements.errorMessage.textContent = message;
            setHidden(elements.errorMessage, false);

            errorTimer = setTimeout(() => {
                setHidden(elements.errorMessage, true);
                errorTimer = null;
            }, 5000);
        }
        /**
         * Hides error message
         */
        function hideError() {
            if (errorTimer) {
                clearTimeout(errorTimer);
                errorTimer = null;
            }
            setHidden(elements.errorMessage, true);
        }

        /**
         * Updates button state
         */
        function setButtonState(isLoading) {
            const LOADING_LABEL = '‚è≥ Generating...';
            const DEFAULT_LABEL = 'Generate Link';
            if (isLoading) {
                elements.btn.disabled = true;
                elements.btn.textContent = LOADING_LABEL;
            } else {
                elements.btn.disabled = false;
                if (elements.btn.textContent === LOADING_LABEL) {
                    elements.btn.textContent = DEFAULT_LABEL;
                }
            }
        }

        function normalizeSourceKey(source) {
            const value = String(source ?? DEFAULT_SOURCE_KEY).trim().toLowerCase();
            if (!/^[a-z0-9_]+$/.test(value)) return DEFAULT_SOURCE_KEY;
            return Object.prototype.hasOwnProperty.call(SOURCES, value) ? value : DEFAULT_SOURCE_KEY;
        }

        function getSourceMeta(source) {
            const key = normalizeSourceKey(source);
            return SOURCES[key] || SOURCES[DEFAULT_SOURCE_KEY];
        }

        function populateSourceSelect() {
            if (!elements.sourceSelect) return;

            const previousRaw = elements.sourceSelect.value;
            const previous = normalizeSourceKey(previousRaw);
            const fragment = document.createDocumentFragment();
            for (const [key, meta] of Object.entries(SOURCES)) {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = `${meta.emoji} ${meta.label}`;
                fragment.appendChild(opt);
            }
            elements.sourceSelect.replaceChildren(fragment);

            if (previousRaw && Object.prototype.hasOwnProperty.call(SOURCES, previous)) {
                elements.sourceSelect.value = previous;
            } else if (Object.prototype.hasOwnProperty.call(SOURCES, 'commission')) {
                elements.sourceSelect.value = 'commission';
            } else {
                elements.sourceSelect.value = DEFAULT_SOURCE_KEY;
            }
        }

        /**
         * Returns a formatted display label with emoji for a source key
         */
        function formatSourceLabel(source) {
            const meta = getSourceMeta(source);
            return `${meta.emoji} ${meta.label}`;
        }

        /**
         * Gets the display label for a select option
         */
        function getSelectedLabel() {
            return formatSourceLabel(elements.sourceSelect.value);
        }

        /**
         * Retry wrapper for database operations
         */
        async function withRetry(operation, retries = CONFIG.MAX_RETRIES) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await operation();
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (i + 1)));
                }
            }
        }

        // ============================================
        // CORE FUNCTIONALITY
        // ============================================

        /**
         * Generates a new review link token
         */
        async function generateLink() {
            Trace.group('GENERATE_LINK_FLOW');
            Trace.log('GENERATE_CLICK', { source: elements.sourceSelect?.value || null });
            hideError();

            if (!db) {
                Trace.log('GENERATE_ABORT_NO_DB');
                showError('Database not connected. Please refresh the page.');
                Trace.groupEnd();
                return;
            }
            
            // 1. Validate source selection
            const sourceValidation = validateSource(elements.sourceSelect.value);
            if (!sourceValidation.valid) {
                Trace.log('VALIDATION_FAILED', { error: sourceValidation.error });
                showError(sourceValidation.error);
                Trace.groupEnd();
                return;
            }

            const selectedSource = sourceValidation.value;
            const selectedLabel = getSelectedLabel();

            setButtonState(true);

            try {
                // 2. Create token via server-side admin function (bcrypt-verified)
                Trace.log('RPC_CREATE_START', { source: selectedSource });

                const { data: rpcResult, error } = await withRetry(async () => {
                    return await db.rpc('admin_create_token', {
                        p_admin_code: adminCode,
                        p_source: selectedSource
                    });
                });

                if (error) {
                    Trace.log('RPC_CREATE_ERROR', { message: error.message || 'Failed to create token' });
                    throw new Error(error.message || 'Failed to create token');
                }

                if (!rpcResult || !rpcResult.success) {
                    const errMsg = rpcResult?.error || 'Failed to create token';
                    Trace.log('RPC_CREATE_DENIED', { error: errMsg });
                    if (errMsg === 'Unauthorized') {
                        adminCode = null;
                        showAuthLockout('Invalid admin code.');
                        return;
                    }
                    throw new Error(errMsg);
                }

                const data = rpcResult.token;
                if (!data || !data.id) {
                    Trace.log('RPC_CREATE_BAD_RESPONSE');
                    throw new Error('Invalid response from server');
                }

                Trace.log('RPC_CREATE_SUCCESS', { tokenId: data.id });

                // 3. Construct and validate URL
                const fullLink = `${CONFIG.SITE_URL}?token=${encodeURIComponent(data.id)}`;
                Trace.log('LINK_BUILT', { url: fullLink });
                
                // Verify URL is valid
                try {
                    new URL(fullLink);
                } catch (e) {
                    Trace.log('LINK_INVALID');
                    throw new Error('Generated invalid URL');
                }

                // 4. Display result
                elements.linkOutput.value = fullLink;
                elements.sourceTag.textContent = `Source: ${selectedLabel}`;
                setHidden(elements.resultArea, false);

                Trace.log('UI_RENDER_RESULT');
                

                // Check if expiration info needs to be cleared (since we removed the feature)
                const existingExpiration = elements.resultArea.querySelector('.expiration-info');
                if (existingExpiration) {
                    existingExpiration.remove();
                }

                
                // Auto-select the link for easy copying
                elements.linkOutput.select();
                
                // Update button text
                elements.btn.textContent = 'Generate Another';

                // Refresh page data after creating new link
                // - clear filters so the new link is visible
                // - reset infinite scroll paging so newest items load first
                state.filter = null;
                if (elements.clearFilterBtn) {
                    setHidden(elements.clearFilterBtn, true);
                }
                resetRecentLinksPaging();
                Trace.log('RECENT_LINKS_REFRESH');
                await loadRecentLinks();

                // Optionally expand links so the new item is visible
                if (!state.links.expanded) {
                    toggleLinksSection();
                }

                Trace.log('GENERATE_DONE', { tokenId: data.id, source: selectedSource });

            } catch (error) {
                console.error('Error generating link:', error);
                Trace.log('GENERATE_FAILED', { message: error?.message || String(error) });
                showError(`Failed to generate link: ${error.message}`);
            } finally {
                setButtonState(false);
                Trace.groupEnd();
            }
        }

        /**
         * Copies link to clipboard
         */
        async function copyToClipboard() {
            const link = elements.linkOutput.value;
            
            if (!link) {
                showError('No link to copy');
                return;
            }

            try {
                Trace.log('COPY_TO_CLIPBOARD', { link });
                // Modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(link);
                } else {
                    // Fallback for older browsers
                    elements.linkOutput.select();
                    document.execCommand('copy');
                }

                // Visual feedback
                const originalText = elements.copyBtn.textContent;
                elements.copyBtn.textContent = '‚úì Copied!';
                elements.copyBtn.classList.add('copied');

                Trace.log('COPY_SUCCESS');

                setTimeout(() => {
                    elements.copyBtn.textContent = originalText;
                    elements.copyBtn.classList.remove('copied');
                }, 2000);

            } catch (error) {
                console.error('Copy failed:', error);
                Trace.log('COPY_FAILED', { message: error?.message || String(error) });
                showError('Failed to copy link. Please select and copy manually.');
            }
        }


        /**
         * Loads and displays recent links
         */
        async function loadRecentLinks(filterSource = null) {
            Trace.group('LOAD_RECENT_LINKS');
            Trace.log('FETCH_START', {
                filter: filterSource,
                offset: state.links.offset,
                pageSize: state.links.pageSize,
                queryKey: state.links.queryKey
            });
            try {
                if (!db) return;
                if (state.links.loading) return;

                state.links.loading = true;

                const queryKey = state.links.queryKey;
                const startOffset = state.links.offset;

                if (elements.recentLinksSentinel) {
                    elements.recentLinksSentinel.textContent = 'Loading‚Ä¶';
                }

                const { data: rpcResult, error } = await db.rpc('admin_list_tokens', {
                    p_admin_code: adminCode,
                    p_source: filterSource,
                    p_offset: startOffset,
                    p_limit: state.links.pageSize
                });

                const data = rpcResult?.items;

                if (!error && rpcResult && rpcResult.success === false && rpcResult.error === 'Unauthorized') {
                    adminCode = null;
                    showAuthLockout('Invalid admin code.');
                    return;
                }

                // If filter/reset happened while awaiting, ignore this response
                if (queryKey !== state.links.queryKey) {
                    Trace.log('FETCH_IGNORED_STALE', { expected: state.links.queryKey, got: queryKey });
                    return;
                }

                if (error) {
                    console.error('Recent links error:', error);
                    Trace.log('FETCH_ERROR', { message: error?.message || String(error) });
                    return;
                }

                if (!rpcResult || rpcResult.success !== true || !Array.isArray(data)) {
                    Trace.log('FETCH_ERROR', { message: rpcResult?.error || 'Invalid response from server' });
                    return;
                }

                Trace.log('FETCH_SUCCESS', { count: data?.length || 0 });

                const isFirstPage = startOffset === 0;
                if (isFirstPage) {
                    if (!data || data.length === 0) {
                        setHidden(elements.recentLinksContainer, true);
                        setHidden(elements.linksDivider, true);
                        setHidden(elements.emptyState, false);
                        if (elements.recentLinksSentinel) elements.recentLinksSentinel.textContent = '';
                        state.links.hasMore = false;
                        return;
                    }
                    setHidden(elements.recentLinksContainer, false);
                    setHidden(elements.linksDivider, false);
                    setHidden(elements.emptyState, true);
                }

                // Update title with filter if applicable
                if (filterSource) {
                    // Clear existing content and rebuild with filter badge
                    elements.recentLinksTitle.textContent = `${formatSourceLabel(filterSource)} Links`;

                    if (elements.clearFilterBtn) {
                        setHidden(elements.clearFilterBtn, false);
                    }
                } else {
                    if (elements.clearFilterBtn) {
                        setHidden(elements.clearFilterBtn, true);
                    }
                    elements.recentLinksTitle.textContent = 'Generated Links';
                }

                // Build links display (DOM nodes, no innerHTML)
                const now = new Date();
                const fragment = document.createDocumentFragment();
                for (const link of (data || [])) {
                    fragment.appendChild(renderLinkItem(link, now));
                }

                if (elements.recentLinksList) {
                    if (isFirstPage) {
                        elements.recentLinksList.replaceChildren(fragment);
                    } else {
                        elements.recentLinksList.appendChild(fragment);
                    }
                }

                // Update pagination state (offset-stable)
                state.links.offset = startOffset + (data?.length || 0);
                state.links.hasMore = (data?.length || 0) === state.links.pageSize;

                Trace.log('FETCH_RENDERED', { offset: state.links.offset, hasMore: state.links.hasMore });

                if (elements.recentLinksSentinel) {
                    if (state.links.hasMore) {
                        elements.recentLinksSentinel.textContent = 'Loading more‚Ä¶';
                    } else {
                        elements.recentLinksSentinel.textContent = 'End of list';
                    }
                }

                ensureLinksObserver();

            } catch (error) {
                console.error('Failed to load recent links:', error);
                Trace.log('FETCH_FAILED', { message: error?.message || String(error) });
            } finally {
                state.links.loading = false;
                Trace.groupEnd();
            }
        }

        function resetRecentLinksPaging() {
            state.links.queryKey++;
            state.links.offset = 0;
            state.links.hasMore = true;
            state.links.loading = false;
            if (elements.recentLinksList) elements.recentLinksList.textContent = '';
            if (elements.recentLinksSentinel) elements.recentLinksSentinel.textContent = '';

            if (state.links.observer) {
                try { state.links.observer.disconnect(); } catch { /* noop */ }
                state.links.observer = null;
            }
        }

        function ensureLinksObserver() {
            if (!elements.recentLinksSentinel) return;
            if (state.links.observer) return;

            state.links.observer = new IntersectionObserver((entries) => {
                const entry = entries[0];
                if (!entry || !entry.isIntersecting) return;
                if (!state.links.expanded) return;
                if (!db) return;
                if (!state.links.hasMore) return;

                loadRecentLinks(state.filter).catch(() => {});
            }, {
                root: null,
                rootMargin: '300px 0px',
                threshold: 0
            });

            state.links.observer.observe(elements.recentLinksSentinel);
        }

        function computeStatusText(link, now) {
            const expiresDate = new Date(link.expires_at);
            const isExpired = expiresDate < now;

            if (link.is_used) return '‚úÖ Used';
            if (isExpired) return '‚ö†Ô∏è Expired';

            const msRemaining = expiresDate - now;
            const daysRemaining = Math.ceil(msRemaining / (1000 * 60 * 60 * 24));
            return `üîµ Active (${daysRemaining} day${daysRemaining !== 1 ? 's' : ''} left)`;
        }

        function renderLinkItem(link, now) {
            const fullLink = `${CONFIG.SITE_URL}?token=${encodeURIComponent(link.id)}`;
            const createdDate = new Date(link.created_at);
            const expiresDate = new Date(link.expires_at);
            const isExpired = expiresDate < now;

            const item = document.createElement('div');
            item.className = 'link-item';

            const header = document.createElement('div');
            header.className = 'link-item-header';

            const sourceBtn = document.createElement('button');
            sourceBtn.className = 'source-name';
            sourceBtn.type = 'button';
            sourceBtn.dataset.action = 'filter';
            sourceBtn.dataset.source = normalizeSourceKey(link.source);
            sourceBtn.title = 'Filter by this source';
            sourceBtn.textContent = formatSourceLabel(link.source);

            const dateStr = createdDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            const timeStr = createdDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dateTimeStr = `${dateStr} at ${timeStr}`;

            const dateSpan = document.createElement('span');
            dateSpan.className = 'link-item-date';
            dateSpan.title = dateTimeStr;
            dateSpan.textContent = `${dateStr} ‚Ä¢ ${timeStr}`;

            header.append(sourceBtn, dateSpan);

            const urlRow = document.createElement('textarea');
            urlRow.className = 'link-item-url link-item-url-field';
            urlRow.readOnly = true;
            urlRow.rows = 2;
            urlRow.value = fullLink;
            urlRow.spellcheck = false;

            const footer = document.createElement('div');
            footer.className = 'link-item-footer';

            const status = document.createElement('span');
            status.className = 'link-item-status text-muted';
            status.textContent = computeStatusText(link, now);

            const actions = document.createElement('div');
            actions.className = 'link-item-actions';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'mini-btn';
            copyBtn.type = 'button';
            copyBtn.dataset.action = 'copy';
            copyBtn.dataset.link = fullLink;
            copyBtn.textContent = 'Copy Link';
            actions.appendChild(copyBtn);

            if (!link.is_used && !isExpired) {
                const testBtn = document.createElement('button');
                testBtn.className = 'mini-btn secondary';
                testBtn.type = 'button';
                testBtn.dataset.action = 'test';
                testBtn.dataset.link = fullLink;
                testBtn.textContent = 'Test';
                actions.appendChild(testBtn);
            }

            const delBtn = document.createElement('button');
            delBtn.className = 'mini-btn danger';
            delBtn.type = 'button';
            delBtn.dataset.action = 'delete';
            delBtn.dataset.id = link.id;
            delBtn.textContent = 'Delete';
            actions.appendChild(delBtn);

            footer.append(status, actions);

            item.append(header, urlRow, footer);
            return item;
        }

        function armDeleteConfirmation(tokenId) {
            const existingTimeout = pendingDeletes.get(tokenId);
            if (existingTimeout) {
                clearTimeout(existingTimeout);
            }
            const timeoutId = setTimeout(() => {
                pendingDeletes.delete(tokenId);
            }, DELETE_CONFIRM_MS);
            pendingDeletes.set(tokenId, timeoutId);
        }

        async function deleteToken(tokenId, buttonEl) {
            Trace.group('DELETE_FLOW');
            Trace.log('DELETE_CLICK', { tokenId });
            if (!db) {
                Trace.log('DELETE_ABORT_NO_DB');
                showError('Database not connected. Please refresh the page.');
                Trace.groupEnd();
                return;
            }

            // Two-click confirm (console-only)
            if (!pendingDeletes.has(tokenId)) {
                armDeleteConfirmation(tokenId);
                Trace.log('DELETE_CONFIRM_ARMED', { ttlMs: DELETE_CONFIRM_MS });
                Trace.groupEnd();
                return;
            }

            // Confirmed
            const timeoutId = pendingDeletes.get(tokenId);
            if (timeoutId) clearTimeout(timeoutId);
            pendingDeletes.delete(tokenId);

            const originalText = buttonEl?.textContent;
            if (buttonEl) {
                buttonEl.disabled = true;
                buttonEl.textContent = 'Deleting...';
            }

            try {
                Trace.log('RPC_DELETE_START');
                const { data: delResult, error } = await db.rpc('admin_delete_token', {
                    p_admin_code: adminCode,
                    p_token_id: String(tokenId)
                });

                if (error) {
                    throw new Error(error.message || 'Delete failed');
                }

                if (!delResult || !delResult.success) {
                    const errMsg = delResult?.error || 'Delete failed';
                    if (errMsg === 'Unauthorized') {
                        adminCode = null;
                        showAuthLockout('Invalid admin code.');
                        return;
                    }
                    throw new Error(errMsg);
                }

                Trace.log('DELETE_SUCCESS');

                // Interlock: Hide result area if the deleted token is currently displayed
                // We check if the current link output contains the deleted token ID
                if (elements.resultArea && !elements.resultArea.classList.contains('is-hidden')) {
                    const currentLink = elements.linkOutput.value;
                    if (currentLink && currentLink.includes(tokenId)) {
                        setHidden(elements.resultArea, true);
                        elements.linkOutput.value = '';
                    }
                }

                // Refresh list and source performance to keep paging consistent
                resetRecentLinksPaging();
                await loadRecentLinks(state.filter);

            } catch (err) {
                console.error('Delete failed:', err);
                Trace.log('DELETE_FAILED', { message: err?.message || String(err) });
                showError(`Failed to delete link: ${err.message}`);
            } finally {
                if (buttonEl) {
                    buttonEl.disabled = false;
                    buttonEl.textContent = originalText || 'Delete';
                }

                Trace.groupEnd();
            }
        }
        
        /**
         * Copies a link to clipboard
         */
        async function copyLinkToClipboard(link) {
            try {
                Trace.log('COPY_RECENT_LINK', { link });
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(link);
                } else {
                    const textarea = document.createElement('textarea');
                    textarea.value = link;
                    textarea.style.position = 'fixed';
                    textarea.style.left = '-9999px';
                    textarea.setAttribute('aria-hidden', 'true');
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                }
                Trace.log('COPY_RECENT_LINK_SUCCESS');
            } catch (error) {
                console.error('Copy failed:', error);
                Trace.log('COPY_RECENT_LINK_FAILED', { message: error?.message || String(error) });
            }
        }
        
        /**
         * Opens a link in new tab
         */
        function openLink(link) {
            Trace.log('USER_OPEN_TEST_LINK', { link });
            window.open(link, '_blank', 'noopener,noreferrer');
        }
        
        /**
         * Filters links by source
         */
        function filterBySource(source) {
            const normalized = normalizeSourceKey(source);
            state.filter = normalized;
            Trace.log('FILTER_APPLIED', { source: normalized });
            resetRecentLinksPaging();
            loadRecentLinks(normalized);

            // Unify filtering UX: expand the Recent Links panel when filtering
            if (!state.links.expanded) {
                state.links.expanded = true;
                setHidden(elements.recentLinks, false);
                elements.expandArrow.classList.toggle('collapsed', false);
                if (elements.recentLinksToggle) {
                    elements.recentLinksToggle.setAttribute('aria-expanded', 'true');
                }
            }
        }
        
        /**
         * Clears the source filter
         */
        function clearFilter() {
            state.filter = null;
            Trace.log('FILTER_CLEARED');
            resetRecentLinksPaging();
            loadRecentLinks();
        }
        
        /**
         * Toggles the links section visibility
         */
        function toggleLinksSection() {
            state.links.expanded = !state.links.expanded;
            Trace.log('LINKS_TOGGLED', { expanded: state.links.expanded });
            setHidden(elements.recentLinks, !state.links.expanded);
            elements.expandArrow.classList.toggle('collapsed', !state.links.expanded);

            if (elements.recentLinksToggle) {
                elements.recentLinksToggle.setAttribute('aria-expanded', String(state.links.expanded));
            }

            if (state.links.expanded) {
                ensureLinksObserver();
            }
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================

        populateSourceSelect();

        if (elements.form) {
            elements.form.addEventListener('submit', (e) => {
                e.preventDefault();
                generateLink();
            });
        } else {
            elements.btn.addEventListener('click', generateLink);
        }
        elements.copyBtn.addEventListener('click', copyToClipboard);

        if (elements.recentLinksToggle) {
            elements.recentLinksToggle.addEventListener('click', () => {
                Trace.log('USER_TOGGLE_SECTION_CLICK');
                toggleLinksSection();
            });
        }

        if (elements.clearFilterBtn) {
            elements.clearFilterBtn.addEventListener('click', (e) => {
                e.preventDefault();
                Trace.log('USER_CLEAR_FILTER_CLICK');
                clearFilter();
            });
        }

        // Allow Enter key on select to generate
        elements.sourceSelect.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                generateLink();
            }
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        Trace.log('UI_READY');

        // Verify admin code server-side, then load data
        if (db) {
            (async () => {
                try {
                    Trace.log('AUTH_SERVER_VERIFY_START');
                    const { data, error } = await db.rpc('verify_admin', { p_admin_code: adminCode });
                    if (error || !data || !data.success) {
                        Trace.log('AUTH_SERVER_DENIED');
                        adminCode = null;
                        showAuthLockout('Invalid admin code.');
                        return;
                    }
                    Trace.log('AUTH_SERVER_VERIFIED');
                    clearAuthLockout();
                } catch (e) {
                    // Network error ‚Äî allow proceeding, individual RPCs will catch invalid codes
                    console.warn('Admin verification network error:', e);
                }
                resetRecentLinksPaging();
                loadRecentLinks();
            })();
        }

        // Handle page visibility changes (refresh when page becomes visible)
        // Cooldown prevents redundant fetches on rapid tab switching
        let lastVisibilityRefresh = 0;
        const VISIBILITY_COOLDOWN_MS = 60_000; // 1 minute

        function onVisibilityChange() {
            if (!document.hidden && db) {
                const now = Date.now();
                if (now - lastVisibilityRefresh < VISIBILITY_COOLDOWN_MS) return;
                lastVisibilityRefresh = now;
                resetRecentLinksPaging();
                loadRecentLinks(state.filter).catch(() => {});
            }
        }

        document.addEventListener('visibilitychange', onVisibilityChange);

        function cleanup() {
            try {
                if (state?.links?.observer) {
                    try { state.links.observer.disconnect(); } catch { /* noop */ }
                    state.links.observer = null;
                }
            } catch { /* noop */ }

            try {
                document.removeEventListener('visibilitychange', onVisibilityChange);
            } catch { /* noop */ }

            try {
                pendingDeletes.forEach((t) => { try { clearTimeout(t); } catch { /* noop */ } });
                pendingDeletes.clear();
            } catch { /* noop */ }
        }

        window.addEventListener('beforeunload', cleanup);

        // ============================================
        // CHANGE ADMIN CODE
        // ============================================
        {
            const changeBtn = document.getElementById('changeCodeBtn');
            const currentInput = document.getElementById('currentCodeInput');
            const newInput = document.getElementById('newCodeInput');
            const confirmInput = document.getElementById('confirmCodeInput');
            const changeMsg = document.getElementById('changeCodeMessage');

            function showChangeMsg(text, isError) {
                changeMsg.textContent = text;
                changeMsg.className = 'gallery-msg ' + (isError ? 'error' : 'success');
                setHidden(changeMsg, false);
            }

            if (changeBtn) {
                changeBtn.addEventListener('click', async () => {
                    setHidden(changeMsg, true);
                    const currentVal = currentInput.value.trim();
                    const newVal = newInput.value.trim();
                    const confirmVal = confirmInput.value.trim();

                    if (!currentVal) { showChangeMsg('Enter your current admin code.', true); return; }
                    if (newVal.length < 4) { showChangeMsg('New code must be at least 4 characters.', true); return; }
                    if (newVal !== confirmVal) { showChangeMsg('New codes do not match.', true); return; }
                    if (newVal === currentVal) { showChangeMsg('New code must be different from current code.', true); return; }

                    changeBtn.disabled = true;
                    changeBtn.textContent = 'Changing...';

                    try {
                        const { data, error } = await db.rpc('admin_change_code', {
                            p_current_code: currentVal,
                            p_new_code: newVal
                        });

                        if (error) throw new Error(error.message);
                        if (!data || !data.success) {
                            const errMsg = data?.error || 'Change failed';
                            showChangeMsg(errMsg, true);
                            return;
                        }

                        // Update in-memory admin code so subsequent actions use the new one
                        adminCode = newVal;
                        currentInput.value = '';
                        newInput.value = '';
                        confirmInput.value = '';
                        showChangeMsg('Admin code changed successfully!', false);
                        Trace.log('ADMIN_CODE_CHANGED');
                    } catch (err) {
                        showChangeMsg('Failed: ' + err.message, true);
                    } finally {
                        changeBtn.disabled = false;
                        changeBtn.textContent = 'Change Admin Code';
                    }
                });
            }
        }

        // ============================================
        // GALLERY MANAGER
        // ============================================
        {
            const gEl = {
                section: document.getElementById('gallerySection'),
                form: document.getElementById('galleryForm'),
                urlInput: document.getElementById('galleryUrl'),
                urlStatus: document.getElementById('galleryUrlStatus'),
                preview: document.getElementById('galleryPreview'),
                titleInput: document.getElementById('galleryTitle'),
                mediumInput: document.getElementById('galleryMedium'),
                yearInput: document.getElementById('galleryYear'),
                captionPreview: document.getElementById('galleryCaptionPreview'),
                addBtn: document.getElementById('galleryAddBtn'),
                message: document.getElementById('galleryMessage'),
                list: document.getElementById('galleryList'),
                count: document.getElementById('galleryCount')
            };

            let galleryLoaded = false;
            let galleryItems = [];
            let lastMovedId = null;
            const galleryDeletePending = new Map();
            const GALLERY_DELETE_MS = 3000;
            const dragDropTarget = { id: null, position: 'before' };

            // ----- Google Drive URL Converter -----
            function extractDriveFileId(url) {
                if (!url || typeof url !== 'string') return null;
                url = url.trim();
                // lh3.googleusercontent.com/d/{ID}
                let m = url.match(/lh3\.googleusercontent\.com\/d\/([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                // drive.google.com/file/d/{ID}/...
                m = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                // drive.google.com/open?id={ID} or /uc?id= or /thumbnail?id=
                m = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                // Bare ID (25+ chars, letters/numbers/dashes/underscores)
                if (/^[a-zA-Z0-9_-]{25,}$/.test(url)) return url;
                return null;
            }

            function toEmbedUrl(fileId) {
                return `https://lh3.googleusercontent.com/d/${fileId}`;
            }

            function buildCaption(title, medium, year) {
                let c = title || '';
                if (medium || year) {
                    c += ' - ';
                    if (medium) c += medium;
                    if (medium && year) c += ' ';
                    if (year) c += year;
                }
                return c;
            }

            // ----- URL Input Handler -----
            let convertedUrl = null;

            function handleUrlInput() {
                const raw = gEl.urlInput.value.trim();
                if (!raw) {
                    setHidden(gEl.urlStatus, true);
                    setHidden(gEl.preview, true);
                    convertedUrl = null;
                    return;
                }

                const fileId = extractDriveFileId(raw);
                if (fileId) {
                    convertedUrl = toEmbedUrl(fileId);
                    gEl.urlStatus.textContent = '‚úÖ Valid Google Drive URL detected';
                    gEl.urlStatus.className = 'gallery-url-status valid';
                    setHidden(gEl.urlStatus, false);
                    // Show preview (no innerHTML)
                    gEl.preview.textContent = '';
                    const img = document.createElement('img');
                    img.alt = 'Preview';
                    img.src = convertedUrl;
                    img.addEventListener('error', () => {
                        gEl.preview.textContent = '';
                        const msg = document.createElement('span');
                        msg.className = 'text-muted-2';
                        msg.style.fontSize = '0.7rem';
                        msg.style.padding = '0.5rem';
                        msg.textContent = 'Could not load preview';
                        gEl.preview.appendChild(msg);
                    }, { once: true });
                    gEl.preview.appendChild(img);
                    setHidden(gEl.preview, false);
                } else {
                    convertedUrl = null;
                    gEl.urlStatus.textContent = '‚ö†Ô∏è Could not detect a Google Drive file ID';
                    gEl.urlStatus.className = 'gallery-url-status invalid';
                    setHidden(gEl.urlStatus, false);
                    setHidden(gEl.preview, true);
                }
            }

            gEl.urlInput.addEventListener('input', handleUrlInput);
            gEl.urlInput.addEventListener('paste', () => setTimeout(handleUrlInput, 50));

            // ----- Caption Preview -----
            function updateCaptionPreview() {
                const t = gEl.titleInput.value.trim();
                const m = gEl.mediumInput.value.trim();
                const y = gEl.yearInput.value.trim();
                if (t) {
                    gEl.captionPreview.textContent = 'Caption: "' + buildCaption(t, m, y) + '"';
                } else {
                    gEl.captionPreview.textContent = '';
                }
            }

            gEl.titleInput.addEventListener('input', updateCaptionPreview);
            gEl.mediumInput.addEventListener('input', updateCaptionPreview);
            gEl.yearInput.addEventListener('input', updateCaptionPreview);

            // ----- Show Gallery Message -----
            function showGalleryMsg(text, isError) {
                gEl.message.textContent = text;
                gEl.message.className = 'gallery-msg ' + (isError ? 'error' : 'success');
                setHidden(gEl.message, false);
                setTimeout(() => setHidden(gEl.message, true), 5000);
            }

            // ----- Add Gallery Item -----
            gEl.form.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!db || !adminCode) return;

                const imgUrl = convertedUrl;
                const title = gEl.titleInput.value.trim();
                const medium = gEl.mediumInput.value.trim() || null;
                const year = gEl.yearInput.value ? parseInt(gEl.yearInput.value, 10) : null;

                if (!imgUrl) {
                    showGalleryMsg('Please paste a valid Google Drive image URL.', true);
                    return;
                }
                if (!title) {
                    showGalleryMsg('Please enter an artwork title.', true);
                    return;
                }

                gEl.addBtn.disabled = true;
                gEl.addBtn.textContent = 'Adding...';

                try {
                    // Calculate next sort order (find max and add 1, starting from 1)
                    const maxSort = galleryItems.length > 0 
                        ? Math.max(...galleryItems.map(i => i.sort_order || 0))
                        : 0;
                    const nextSort = Math.max(1, maxSort + 1);

                    const { data, error } = await db.rpc('admin_add_gallery_item', {
                        p_admin_code: adminCode,
                        p_img_url: imgUrl,
                        p_title: title,
                        p_medium: medium,
                        p_year_created: year,
                        p_sort_order: nextSort
                    });

                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showGalleryMsg(data?.error || 'Failed to add item', true);
                        return;
                    }

                    showGalleryMsg('Artwork added to gallery! Visitors will see it on page refresh.', false);
                    // Reset form
                    gEl.form.reset();
                    convertedUrl = null;
                    setHidden(gEl.urlStatus, true);
                    setHidden(gEl.preview, true);
                    gEl.captionPreview.textContent = '';
                    // Reload list
                    loadGalleryItems();
                } catch (err) {
                    showGalleryMsg('Error: ' + err.message, true);
                } finally {
                    gEl.addBtn.disabled = false;
                    gEl.addBtn.textContent = 'Add to Gallery';
                }
            });

            // ----- Load Gallery Items -----
            async function loadGalleryItems() {
                if (!db || !adminCode) return;

                try {
                    const { data, error } = await db.rpc('admin_list_gallery', {
                        p_admin_code: adminCode
                    });

                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        gEl.list.textContent = '';
                        const p = document.createElement('p');
                        p.className = 'text-danger';
                        p.style.fontSize = '0.85rem';
                        p.textContent = String(data?.error || 'Failed to load');
                        gEl.list.appendChild(p);
                        return;
                    }

                    galleryItems = data.items || [];
                    renderGalleryItems();
                    galleryLoaded = true;
                } catch (err) {
                    gEl.list.textContent = '';
                    const p = document.createElement('p');
                    p.className = 'text-danger';
                    p.style.fontSize = '0.85rem';
                    p.textContent = 'Error: ' + String(err?.message || err || 'Unknown error');
                    gEl.list.appendChild(p);
                }
            }

            // ----- Render Gallery Items -----
            function renderGalleryItems() {
                const active = galleryItems.filter(i => i.is_active).length;
                const total = galleryItems.length;
                gEl.count.textContent = `${active} active / ${total} total items`;

                if (total === 0) {
                    gEl.list.textContent = '';
                    const p = document.createElement('p');
                    p.className = 'text-muted-2';
                    p.style.fontSize = '0.85rem';
                    p.textContent = 'No gallery items yet. Add your first artwork above!';
                    gEl.list.appendChild(p);
                    return;
                }

                gEl.list.textContent = '';
                const fragment = document.createDocumentFragment();

                for (const item of galleryItems) {
                    const caption = buildCaption(item.title, item.medium, item.year_created);
                    const isActive = Boolean(item.is_active);
                    const date = new Date(item.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    const flashClass = String(item.id) === String(lastMovedId) ? ' flash' : '';

                    const row = document.createElement('div');
                    row.className = 'gallery-item ' + (isActive ? '' : 'inactive') + flashClass;
                    row.setAttribute('data-gallery-id', String(item.id));

                    const handle = document.createElement('span');
                    handle.className = 'drag-handle';
                    handle.title = 'Drag to reorder';
                    handle.textContent = '‚†ø';

                    const thumb = document.createElement('div');
                    thumb.className = 'gallery-item-thumb';
                    if (typeof item.img_url === 'string' && item.img_url.startsWith('http')) {
                        const img = document.createElement('img');
                        img.loading = 'lazy';
                        img.alt = String(item.title || 'Artwork');
                        img.src = item.img_url;
                        img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                        thumb.appendChild(img);
                    } else {
                        const fallback = document.createElement('span');
                        fallback.style.display = 'flex';
                        fallback.style.alignItems = 'center';
                        fallback.style.justifyContent = 'center';
                        fallback.style.height = '100%';
                        fallback.style.fontSize = '1.2rem';
                        fallback.textContent = 'üñºÔ∏è';
                        thumb.appendChild(fallback);
                    }

                    const info = document.createElement('div');
                    info.className = 'gallery-item-info';
                    const title = document.createElement('div');
                    title.className = 'gallery-item-title';
                    title.textContent = caption;
                    const meta = document.createElement('div');
                    meta.className = 'gallery-item-meta';
                    meta.textContent = 'Added ' + date;
                    info.append(title, meta);

                    const sortInput = document.createElement('input');
                    sortInput.type = 'number';
                    sortInput.className = 'gallery-sort-input';
                    sortInput.min = '1';
                    sortInput.max = '9999';
                    sortInput.title = 'Position (1 = first)';
                    sortInput.setAttribute('data-gallery-action', 'sort');
                    sortInput.setAttribute('data-gallery-id', String(item.id));
                    sortInput.setAttribute('aria-label', 'Sort order for ' + String(item.title || 'Artwork'));
                    const safeSort = Number.isFinite(Number(item.sort_order)) ? Math.max(1, Number(item.sort_order)) : 1;
                    sortInput.value = String(safeSort);

                    const actions = document.createElement('div');
                    actions.className = 'gallery-item-actions';

                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'mini-btn gallery-item-badge ' + (isActive ? 'active' : 'hidden');
                    toggleBtn.setAttribute('role', 'switch');
                    toggleBtn.setAttribute('aria-checked', String(isActive));
                    toggleBtn.setAttribute('data-gallery-action', 'toggle');
                    toggleBtn.setAttribute('data-gallery-id', String(item.id));
                    toggleBtn.title = 'Click to ' + (isActive ? 'hide' : 'show');
                    toggleBtn.textContent = isActive ? 'üëÅÔ∏è' : 'üö´';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'mini-btn secondary';
                    editBtn.setAttribute('data-gallery-action', 'edit');
                    editBtn.setAttribute('data-gallery-id', String(item.id));
                    editBtn.title = 'Edit details';
                    editBtn.textContent = '‚úèÔ∏è';

                    const delBtn = document.createElement('button');
                    delBtn.className = 'mini-btn danger';
                    delBtn.setAttribute('data-gallery-action', 'delete');
                    delBtn.setAttribute('data-gallery-id', String(item.id));
                    delBtn.title = 'Delete permanently';
                    delBtn.textContent = 'üóëÔ∏è';

                    actions.append(toggleBtn, editBtn, delBtn);
                    row.append(handle, thumb, info, sortInput, actions);
                    fragment.appendChild(row);
                }

                gEl.list.appendChild(fragment);

                if (lastMovedId !== null) {
                    setTimeout(() => { lastMovedId = null; }, 0);
                }
            }

            // ----- Toggle Gallery Item -----
            async function toggleGalleryItem(id, btn) {
                if (!db || !adminCode) return;
                btn.disabled = true;
                try {
                    const { data, error } = await db.rpc('admin_toggle_gallery_item', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(id, 10)
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showGalleryMsg(data?.error || 'Toggle failed', true);
                        return;
                    }
                    showGalleryMsg(data.is_active ? 'Item is now visible in gallery' : 'Item hidden from gallery', false);
                    loadGalleryItems();
                } catch (err) {
                    showGalleryMsg('Error: ' + err.message, true);
                } finally {
                    btn.disabled = false;
                }
            }

            // ----- Delete Gallery Item (double-click to confirm) -----
            async function deleteGalleryItem(id, btn) {
                // First click = arm confirmation
                if (!galleryDeletePending.has(id)) {
                    galleryDeletePending.set(id, true);
                    btn.textContent = '‚ö†Ô∏è Sure?';
                    btn.classList.remove('danger');
                    btn.classList.add('confirm-armed');
                    setTimeout(() => {
                        if (galleryDeletePending.has(id)) {
                            galleryDeletePending.delete(id);
                            btn.textContent = 'üóëÔ∏è';
                            btn.classList.remove('confirm-armed');
                            btn.classList.add('danger');
                        }
                    }, GALLERY_DELETE_MS);
                    return;
                }

                // Second click = confirmed
                galleryDeletePending.delete(id);
                btn.disabled = true;
                btn.textContent = '...';

                try {
                    const { data, error } = await db.rpc('admin_delete_gallery_item', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(id, 10)
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showGalleryMsg(data?.error || 'Delete failed', true);
                        return;
                    }
                    showGalleryMsg('Item deleted permanently', false);
                    loadGalleryItems();
                } catch (err) {
                    showGalleryMsg('Error: ' + err.message, true);
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üóëÔ∏è';
                    btn.classList.remove('confirm-armed');
                    btn.classList.add('danger');
                }
            }

            // ----- Edit Gallery Item (modal) -----
            let editOverlay = null;
            let editConvertedUrl = null;
            let editEscHandler = null;

            function setPreviewImage(container, url, altText) {
                if (!container) return;
                container.textContent = '';
                if (!url) {
                    const fallback = document.createElement('span');
                    fallback.style.display = 'flex';
                    fallback.style.alignItems = 'center';
                    fallback.style.justifyContent = 'center';
                    fallback.style.height = '100%';
                    fallback.style.fontSize = '2rem';
                    fallback.textContent = 'üñºÔ∏è';
                    container.appendChild(fallback);
                    return;
                }
                const img = document.createElement('img');
                img.alt = altText || 'Preview';
                img.src = url;
                img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                container.appendChild(img);
            }

            function openEditModal(id) {
                const item = galleryItems.find(i => String(i.id) === String(id));
                if (!item) return;

                // Remove existing overlay if any
                if (editOverlay) editOverlay.remove();
                editConvertedUrl = null;

                editOverlay = document.createElement('div');
                editOverlay.className = 'gallery-edit-overlay';
                // Static skeleton only; all item values are assigned via properties/textContent
                editOverlay.innerHTML = `
                    <div class="gallery-edit-modal">
                        <h3>‚úèÔ∏è Edit Artwork</h3>
                        <div id="editMessage" class="gallery-edit-message is-hidden"></div>
                        <div class="gallery-edit-preview">
                            <div class="gallery-edit-preview-img" id="editPreviewImg"></div>
                            <div class="gallery-edit-preview-text">
                                <div style="font-weight:600;font-size:0.9rem;color:var(--color-text);" id="editPreviewCaption"></div>
                                <div class="gallery-edit-preview-caption" id="editPreviewSubtext"></div>
                            </div>
                        </div>
                        <form class="gallery-form" id="galleryEditForm">
                            <label for="editUrl">Image URL</label>
                            <input type="text" id="editUrl" placeholder="Paste Google Drive share link or direct image URL" required>
                            <div id="editUrlStatus" class="gallery-url-status is-hidden"></div>

                            <label for="editTitle">Title</label>
                            <input type="text" id="editTitle" required>
                            <label for="editMedium">Medium</label>
                            <input type="text" id="editMedium" list="mediumOptions" placeholder="e.g. Digital, Canvas, Physical">
                            <label for="editYear">Year</label>
                            <input type="number" id="editYear" min="1900" max="2100" placeholder="e.g. 2024">
                            <label for="editSortOrder">Position (1 = first, higher numbers shown later)</label>
                            <input type="number" id="editSortOrder" min="1" max="9999" placeholder="e.g. 1">

                            <div class="gallery-edit-visibility">
                                <label>Visibility Status</label>
                                <button type="button" id="editActiveToggle" class="mini-btn gallery-item-badge" role="switch" aria-checked="false" data-active="false">üö´</button>
                            </div>

                            <div class="gallery-edit-actions">
                                <button type="button" class="gallery-edit-cancel" id="editCancelBtn">Cancel</button>
                                <button type="submit" class="gallery-add-btn" id="editSaveBtn">Save Changes</button>
                            </div>
                        </form>
                    </div>
                `;

                document.body.appendChild(editOverlay);

                const urlInput = editOverlay.querySelector('#editUrl');
                const urlStatus = editOverlay.querySelector('#editUrlStatus');
                const previewImg = editOverlay.querySelector('#editPreviewImg');
                const titleInput = editOverlay.querySelector('#editTitle');
                const mediumInput = editOverlay.querySelector('#editMedium');
                const yearInput = editOverlay.querySelector('#editYear');
                const activeToggle = editOverlay.querySelector('#editActiveToggle');
                const previewCaption = editOverlay.querySelector('#editPreviewCaption');
                const previewSubtext = editOverlay.querySelector('#editPreviewSubtext');
                const editMessage = editOverlay.querySelector('#editMessage');

                // Seed modal fields safely
                urlInput.value = String(item.img_url || '');
                titleInput.value = String(item.title || '');
                mediumInput.value = String(item.medium || '');
                yearInput.value = item.year_created ? String(item.year_created) : '';
                editOverlay.querySelector('#editSortOrder').value = String(Math.max(1, Number(item.sort_order) || 1));

                setPreviewImage(previewImg, (typeof item.img_url === 'string' && item.img_url.startsWith('http')) ? item.img_url : '', 'Current artwork');
                previewCaption.textContent = buildCaption(item.title, item.medium, item.year_created);
                previewSubtext.textContent = item.is_active ? '‚úÖ Visible on site' : 'üö´ Hidden from site';

                activeToggle.dataset.active = String(Boolean(item.is_active));
                activeToggle.setAttribute('aria-checked', String(Boolean(item.is_active)));
                activeToggle.className = 'mini-btn gallery-item-badge ' + (item.is_active ? 'active' : 'hidden');
                activeToggle.title = 'Click to ' + (item.is_active ? 'hide' : 'show');
                activeToggle.textContent = item.is_active ? 'üëÅÔ∏è' : 'üö´';

                // Active toggle button handler
                activeToggle.addEventListener('click', () => {
                    const isActive = activeToggle.dataset.active === 'true';
                    const newActive = !isActive;
                    activeToggle.dataset.active = String(newActive);
                    activeToggle.setAttribute('aria-checked', String(newActive));
                    activeToggle.className = 'mini-btn gallery-item-badge ' + (newActive ? 'active' : 'hidden');
                    activeToggle.title = 'Click to ' + (newActive ? 'hide' : 'show');
                    activeToggle.textContent = newActive ? 'üëÅÔ∏è' : 'üö´';
                    previewSubtext.textContent = newActive ? '‚úÖ Visible on site' : 'üö´ Hidden from site';
                });

                // URL input handler with Google Drive converter
                function handleEditUrlInput() {
                    const raw = urlInput.value.trim();
                    if (!raw) {
                        urlStatus.classList.add('is-hidden');
                        editConvertedUrl = null;
                        return;
                    }

                    const fileId = extractDriveFileId(raw);
                    if (fileId) {
                        const embedUrl = toEmbedUrl(fileId);
                        editConvertedUrl = embedUrl;
                        urlStatus.textContent = '‚úÖ Google Drive link converted';
                        urlStatus.className = 'gallery-url-status valid';
                        setPreviewImage(previewImg, embedUrl, 'Preview');
                    } else {
                        editConvertedUrl = null;
                        if (raw.startsWith('http')) {
                            urlStatus.textContent = '‚úÖ Direct URL detected';
                            urlStatus.className = 'gallery-url-status valid';
                            setPreviewImage(previewImg, raw, 'Preview');
                        } else {
                            urlStatus.textContent = '‚ö†Ô∏è Invalid URL format';
                            urlStatus.className = 'gallery-url-status invalid';
                        }
                    }
                }

                // Live caption preview update
                function updateEditCaptionPreview() {
                    const title = titleInput.value.trim() || 'Untitled';
                    const medium = mediumInput.value.trim();
                    const year = yearInput.value;
                    previewCaption.textContent = buildCaption(title, medium, year);
                }

                // Active toggle preview
                function updateEditActivePreview() {
                    const isActive = activeToggle.dataset.active === 'true';
                    previewSubtext.textContent = isActive ? '‚úÖ Visible on site' : 'üö´ Hidden from site';
                }

                // Attach live preview handlers
                urlInput.addEventListener('input', handleEditUrlInput);
                urlInput.addEventListener('paste', () => setTimeout(handleEditUrlInput, 50));
                titleInput.addEventListener('input', updateEditCaptionPreview);
                mediumInput.addEventListener('input', updateEditCaptionPreview);
                yearInput.addEventListener('input', updateEditCaptionPreview);

                // Focus title input
                titleInput.focus();
                titleInput.select();

                // Close on backdrop click
                editOverlay.addEventListener('click', (ev) => {
                    if (ev.target === editOverlay) closeEditModal();
                });

                // Cancel button
                editOverlay.querySelector('#editCancelBtn').addEventListener('click', closeEditModal);

                // Focus trap ‚Äî keep Tab cycling inside the modal
                const modal = editOverlay.querySelector('.gallery-edit-modal');
                modal.addEventListener('keydown', (ev) => {
                    if (ev.key !== 'Tab') return;
                    const focusable = modal.querySelectorAll(
                        'input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex="-1"])'
                    );
                    if (!focusable.length) return;
                    const first = focusable[0];
                    const last = focusable[focusable.length - 1];
                    if (ev.shiftKey && document.activeElement === first) {
                        ev.preventDefault();
                        last.focus();
                    } else if (!ev.shiftKey && document.activeElement === last) {
                        ev.preventDefault();
                        first.focus();
                    }
                });

                // Escape key
                if (editEscHandler) {
                    document.removeEventListener('keydown', editEscHandler);
                }
                editEscHandler = (ev) => {
                    if (ev.key === 'Escape') closeEditModal();
                };
                document.addEventListener('keydown', editEscHandler);

                // Helper to show inline message
                function showEditMessage(text, isError) {
                    editMessage.textContent = text;
                    editMessage.className = isError ? 'gallery-edit-message error' : 'gallery-edit-message success';
                    editMessage.classList.remove('is-hidden');
                    setTimeout(() => editMessage.classList.add('is-hidden'), 4000);
                }

                // Save
                editOverlay.querySelector('#galleryEditForm').addEventListener('submit', async (ev) => {
                    ev.preventDefault();
                    
                    const newUrl = editConvertedUrl || urlInput.value.trim();
                    const newTitle = titleInput.value.trim();
                    const newMedium = mediumInput.value.trim() || null;
                    const newYear = yearInput.value ? parseInt(yearInput.value, 10) : null;
                    const newSort = editOverlay.querySelector('#editSortOrder').value !== '' ? Math.max(1, parseInt(editOverlay.querySelector('#editSortOrder').value, 10)) : 1;
                    const newActive = activeToggle.dataset.active === 'true';

                    if (!newUrl) { showEditMessage('Image URL is required.', true); return; }
                    if (!newTitle) { showEditMessage('Title is required.', true); return; }

                    const saveBtn = editOverlay.querySelector('#editSaveBtn');
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';

                    try {
                        const { data, error } = await db.rpc('admin_edit_gallery_item', {
                            p_admin_code: adminCode,
                            p_item_id: parseInt(id, 10),
                            p_img_url: newUrl,
                            p_title: newTitle,
                            p_medium: newMedium,
                            p_year_created: newYear,
                            p_sort_order: newSort,
                            p_is_active: newActive
                        });
                        if (error) throw new Error(error.message);
                        if (!data || !data.success) {
                            showEditMessage(data?.error || 'Update failed', true);
                            saveBtn.disabled = false;
                            saveBtn.textContent = 'Save Changes';
                            return;
                        }
                        showEditMessage('‚úÖ Artwork updated successfully!', false);

                        // If sort_order changed, issue a reorder RPC
                        if (newSort !== item.sort_order) {
                            try {
                                await db.rpc('admin_reorder_gallery_item', {
                                    p_admin_code: adminCode,
                                    p_item_id: parseInt(id, 10),
                                    p_new_sort_order: newSort
                                });
                            } catch (_) { /* best-effort */ }
                        }

                        setTimeout(() => {
                            closeEditModal();
                            loadGalleryItems();
                        }, 1000);
                    } catch (err) {
                        showEditMessage('Error: ' + err.message, true);
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'Save Changes';
                    }
                });
            }

            function closeEditModal() {
                if (editEscHandler) {
                    document.removeEventListener('keydown', editEscHandler);
                    editEscHandler = null;
                }
                if (editOverlay) {
                    editOverlay.remove();
                    editOverlay = null;
                }
            }

            // ----- Event Delegation for Gallery List -----
            gEl.list.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (!btn) return;
                const action = btn.getAttribute('data-gallery-action');
                const id = btn.getAttribute('data-gallery-id');
                if (!action || !id) return;

                if (action === 'toggle') toggleGalleryItem(id, btn);
                if (action === 'edit') openEditModal(id);
                if (action === 'delete') deleteGalleryItem(id, btn);
            });

            // ----- Quiet Background Sync (updates local state + inputs, no DOM rebuild) -----
            async function syncSortOrders() {
                if (!db || !adminCode) return;
                try {
                    const { data, error } = await db.rpc('admin_list_gallery', {
                        p_admin_code: adminCode
                    });
                    if (error || !data || !data.success) return;
                    const serverItems = data.items || [];
                    // Build a lookup from server
                    const serverMap = new Map(serverItems.map(i => [String(i.id), i]));
                    // Update local array with server sort_order values
                    galleryItems.forEach(item => {
                        const server = serverMap.get(String(item.id));
                        if (server) item.sort_order = server.sort_order;
                    });
                    // Re-sort local array to match server order
                    galleryItems.sort((a, b) => a.sort_order - b.sort_order);
                    // Patch the DOM inputs in-place
                    galleryItems.forEach(item => {
                        const input = gEl.list.querySelector(`input.gallery-sort-input[data-gallery-id="${item.id}"]`);
                        if (input) input.value = item.sort_order;
                    });
                } catch (_) { /* best-effort */ }
            }

            // ----- Inline Sort-Order Save -----
            async function saveSortOrder(input) {
                const id = input.getAttribute('data-gallery-id');
                const item = galleryItems.find(i => String(i.id) === String(id));
                if (!item) return;
                let newVal = parseInt(input.value, 10);
                if (isNaN(newVal) || newVal < 1) {
                    input.value = Math.max(1, item.sort_order);
                    return;
                }
                if (newVal === item.sort_order) return;

                input.disabled = true;
                try {
                    const { data, error } = await db.rpc('admin_reorder_gallery_item', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(id, 10),
                        p_new_sort_order: newVal
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) { showGalleryMsg(data?.error || 'Sort update failed', true); return; }
                    showGalleryMsg(`Position updated to ${newVal}`, false);
                    loadGalleryItems();
                } catch (err) {
                    showGalleryMsg('Error: ' + err.message, true);
                } finally {
                    input.disabled = false;
                }
            }

            gEl.list.addEventListener('change', (e) => {
                if (e.target.matches('.gallery-sort-input')) saveSortOrder(e.target);
            });
            gEl.list.addEventListener('keydown', (e) => {
                if (e.target.matches('.gallery-sort-input') && e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur(); // triggers change event
                }
            });

            // ----- Drag & Drop Reorder (Desktop + Touch) -----
            let dragSrcId = null;
            let currentDropTarget = null;

            function clearDropIndicators() {
                if (!gEl.list) return;
                gEl.list.querySelectorAll('.drag-over, .drop-before, .drop-after').forEach(el => {
                    el.classList.remove('drag-over', 'drop-before', 'drop-after');
                });
                currentDropTarget = null;
            }

            /** Shared helper: update the drop-indicator on a target row */
            function updateDropIndicator(row, clientY) {
                if (!row || row.getAttribute('data-gallery-id') === dragSrcId) {
                    // Hovering over source or outside ‚Äî clear stale indicators
                    if (currentDropTarget) {
                        currentDropTarget.classList.remove('drag-over', 'drop-before', 'drop-after');
                        currentDropTarget = null;
                    }
                    dragDropTarget.id = null;
                    return;
                }
                const rect = row.getBoundingClientRect();
                const isBefore = (clientY - rect.top) < rect.height / 2;

                // Switch highlight to new row (avoid clearing everything each frame)
                if (currentDropTarget && currentDropTarget !== row) {
                    currentDropTarget.classList.remove('drag-over', 'drop-before', 'drop-after');
                }
                currentDropTarget = row;
                row.classList.remove('drop-before', 'drop-after');
                row.classList.add('drag-over', isBefore ? 'drop-before' : 'drop-after');

                dragDropTarget.id = row.getAttribute('data-gallery-id');
                dragDropTarget.position = isBefore ? 'before' : 'after';
            }

            /** Optimistically reorder the DOM immediately, then sync server */
            function optimisticReorder(srcId, tgtId, position) {
                const srcEl = gEl.list.querySelector(`[data-gallery-id="${srcId}"]`);
                const tgtEl = gEl.list.querySelector(`[data-gallery-id="${tgtId}"]`);
                if (!srcEl || !tgtEl) return;

                // Move the DOM node directly (no re-render, no scroll jump)
                if (position === 'before') {
                    tgtEl.parentNode.insertBefore(srcEl, tgtEl);
                } else {
                    tgtEl.parentNode.insertBefore(srcEl, tgtEl.nextSibling);
                }

                // Brief "just landed" class to suppress transition flicker
                srcEl.classList.add('dropped');
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => srcEl.classList.remove('dropped'));
                });

                // Update local galleryItems array to match new order
                const srcIdx = galleryItems.findIndex(i => String(i.id) === String(srcId));
                const tgtIdx = galleryItems.findIndex(i => String(i.id) === String(tgtId));
                if (srcIdx !== -1 && tgtIdx !== -1) {
                    const [moved] = galleryItems.splice(srcIdx, 1);
                    const newTgtIdx = galleryItems.findIndex(i => String(i.id) === String(tgtId));
                    if (newTgtIdx !== -1) {
                        const insertAt = position === 'before' ? newTgtIdx : newTgtIdx + 1;
                        galleryItems.splice(insertAt, 0, moved);
                    }
                    // Renumber sort_order locally
                    galleryItems.forEach((item, i) => { item.sort_order = i + 1; });
                    // Update sort-order inputs in-place
                    galleryItems.forEach(item => {
                        const input = gEl.list.querySelector(`input.gallery-sort-input[data-gallery-id="${item.id}"]`);
                        if (input) input.value = item.sort_order;
                    });
                }
            }

            /** Shared helper: execute the move/swap RPC after a drop */
            async function performDrop() {
                const targetId = dragDropTarget.id;
                const targetPosition = dragDropTarget.position || 'before';
                clearDropIndicators();

                if (!dragSrcId || !targetId || dragSrcId === targetId) return;

                // Snapshot for immediate rollback (no network fetch required)
                const snapshot = galleryItems.map(i => ({ ...i }));

                // Optimistic: move the DOM node instantly (no flicker, no scroll jump)
                optimisticReorder(dragSrcId, targetId, targetPosition);

                // Sync to server in background
                try {
                    const { data, error } = await db.rpc('admin_move_gallery_item', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(dragSrcId, 10),
                        p_target_id: parseInt(targetId, 10),
                        p_position: targetPosition
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showGalleryMsg(data?.error || 'Move failed ‚Äî reverting', true);
                        galleryItems = snapshot;
                        renderGalleryItems();
                        return;
                    }
                    // Quietly sync sort_order numbers from server
                    syncSortOrders();
                } catch (err) {
                    showGalleryMsg('Error: ' + (err?.message || err) + ' ‚Äî reverting', true);
                    galleryItems = snapshot;
                    renderGalleryItems();
                }
            }

            // ‚Äî‚Äî‚Äî Shared pointer drag (mouse + touch) ‚Äî‚Äî‚Äî
            // Uses manual clone instead of HTML5 drag ‚Äî no ghost, no snap-back.

            let dragClone = null;
            let dragSourceRow = null;
            let dragOffsetY = 0;

            /** Start a drag from a pointer (mouse or touch) */
            function startDrag(row, clientX, clientY) {
                // Clear any existing text selection immediately
                const sel = window.getSelection();
                if (sel) sel.removeAllRanges();

                dragSrcId = row.getAttribute('data-gallery-id');
                dragSourceRow = row;
                row.classList.add('dragging');
                document.body.classList.add('is-dragging');

                // Build a floating clone that follows the pointer
                const rect = row.getBoundingClientRect();
                dragOffsetY = clientY - rect.top;
                dragClone = row.cloneNode(true);
                dragClone.style.cssText =
                    'position:fixed;pointer-events:none;z-index:10000;transition:none;' +
                    'transform:scale(0.97);opacity:0.88;' +
                    'box-shadow:0 8px 25px rgba(0,0,0,0.18);border-radius:8px;' +
                    'width:' + rect.width + 'px;' +
                    'left:' + rect.left + 'px;' +
                    'top:' + rect.top + 'px;';
                document.body.appendChild(dragClone);
            }

            /** Move the clone + update indicator */
            function moveDrag(clientX, clientY) {
                if (dragClone) {
                    dragClone.style.top = (clientY - dragOffsetY) + 'px';
                }
                // Temporarily hide the source row from hit-testing so
                // elementFromPoint finds the row *underneath* instead
                if (dragSourceRow) dragSourceRow.style.pointerEvents = 'none';
                const elBelow = document.elementFromPoint(clientX, clientY);
                if (dragSourceRow) dragSourceRow.style.pointerEvents = '';
                const row = elBelow ? elBelow.closest('[data-gallery-id]') : null;
                updateDropIndicator(row, clientY);
            }

            /** End drag, perform drop, clean up */
            async function endDrag() {
                if (dragSourceRow) dragSourceRow.classList.remove('dragging');
                if (dragClone) { dragClone.remove(); dragClone = null; }
                document.body.classList.remove('is-dragging');

                await performDrop();

                dragSourceRow = null;
                dragSrcId = null;
                dragDropTarget.id = null;
                dragDropTarget.position = 'before';
            }

            // ‚Äî‚Äî‚Äî Mouse events (desktop) ‚Äî‚Äî‚Äî

            gEl.list.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.drag-handle');
                if (!handle) return;
                const row = handle.closest('.gallery-item');
                if (!row) return;
                e.preventDefault(); // prevent text selection

                startDrag(row, e.clientX, e.clientY);

                function onMouseMove(ev) {
                    ev.preventDefault();
                    moveDrag(ev.clientX, ev.clientY);
                }

                async function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    await endDrag();
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            // Prevent native HTML5 drag on gallery items entirely
            gEl.list.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });

            // ‚Äî‚Äî‚Äî Touch events (mobile / tablet) ‚Äî‚Äî‚Äî

            gEl.list.addEventListener('touchstart', (e) => {
                const handle = e.target.closest('.drag-handle');
                if (!handle) return;
                const row = handle.closest('.gallery-item');
                if (!row) return;

                const touch = e.touches[0];
                startDrag(row, touch.clientX, touch.clientY);
            }, { passive: true });

            gEl.list.addEventListener('touchmove', (e) => {
                if (!dragSourceRow) return;
                e.preventDefault(); // prevent scrolling while dragging
                const touch = e.touches[0];
                moveDrag(touch.clientX, touch.clientY);
            }, { passive: false });

            gEl.list.addEventListener('touchend', async () => {
                if (!dragSourceRow) return;
                await endDrag();
            });

            // ----- Load on section open -----
            gEl.section.addEventListener('toggle', () => {
                if (gEl.section.open && !galleryLoaded && db && adminCode) {
                    loadGalleryItems();
                }
            });
        }

        // ============================================
        // HERO SLIDESHOW MANAGER
        // ============================================
        {
            const hEl = {
                section: document.getElementById('heroSection'),
                form: document.getElementById('heroForm'),
                urlInput: document.getElementById('heroUrl'),
                urlStatus: document.getElementById('heroUrlStatus'),
                preview: document.getElementById('heroPreview'),
                addBtn: document.getElementById('heroAddBtn'),
                message: document.getElementById('heroMessage'),
                list: document.getElementById('heroList'),
                count: document.getElementById('heroCount')
            };

            let heroLoaded = false;
            let heroItems = [];
            let heroLastMovedId = null;
            const heroDeletePending = new Map();
            const HERO_DELETE_MS = 3000;
            const heroDragDropTarget = { id: null, position: 'before' };

            // ----- Google Drive URL Converter (reuses gallery logic) -----
            function heroExtractDriveFileId(url) {
                if (!url || typeof url !== 'string') return null;
                url = url.trim();
                let m = url.match(/lh3\.googleusercontent\.com\/d\/([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                m = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                m = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);
                if (m) return m[1];
                if (/^[a-zA-Z0-9_-]{25,}$/.test(url)) return url;
                return null;
            }

            function heroToEmbedUrl(fileId) {
                return `https://lh3.googleusercontent.com/d/${fileId}`;
            }

            // ----- URL Input Handler -----
            let heroConvertedUrl = null;

            function handleHeroUrlInput() {
                const raw = hEl.urlInput.value.trim();
                if (!raw) {
                    setHidden(hEl.urlStatus, true);
                    setHidden(hEl.preview, true);
                    heroConvertedUrl = null;
                    return;
                }

                const fileId = heroExtractDriveFileId(raw);
                if (fileId) {
                    heroConvertedUrl = heroToEmbedUrl(fileId);
                    hEl.urlStatus.textContent = '‚úÖ Valid Google Drive URL detected';
                    hEl.urlStatus.className = 'gallery-url-status valid';
                    setHidden(hEl.urlStatus, false);
                    hEl.preview.textContent = '';
                    const img = document.createElement('img');
                    img.alt = 'Preview';
                    img.src = heroConvertedUrl;
                    img.addEventListener('error', () => {
                        hEl.preview.textContent = '';
                        const msg = document.createElement('span');
                        msg.className = 'text-muted-2';
                        msg.style.fontSize = '0.7rem';
                        msg.style.padding = '0.5rem';
                        msg.textContent = 'Could not load preview';
                        hEl.preview.appendChild(msg);
                    }, { once: true });
                    hEl.preview.appendChild(img);
                    setHidden(hEl.preview, false);
                } else {
                    heroConvertedUrl = null;
                    hEl.urlStatus.textContent = '‚ö†Ô∏è Could not detect a Google Drive file ID';
                    hEl.urlStatus.className = 'gallery-url-status invalid';
                    setHidden(hEl.urlStatus, false);
                    setHidden(hEl.preview, true);
                }
            }

            hEl.urlInput.addEventListener('input', handleHeroUrlInput);
            hEl.urlInput.addEventListener('paste', () => setTimeout(handleHeroUrlInput, 50));

            // ----- Show Hero Message -----
            function showHeroMsg(text, isError) {
                hEl.message.textContent = text;
                hEl.message.className = 'gallery-msg ' + (isError ? 'error' : 'success');
                setHidden(hEl.message, false);
                setTimeout(() => setHidden(hEl.message, true), 5000);
            }

            // ----- Add Hero Slide -----
            hEl.form.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!db || !adminCode) return;

                const imgUrl = heroConvertedUrl;
                if (!imgUrl) {
                    showHeroMsg('Please paste a valid Google Drive image URL.', true);
                    return;
                }

                hEl.addBtn.disabled = true;
                hEl.addBtn.textContent = 'Adding...';

                try {
                    const { data, error } = await db.rpc('admin_add_hero_slide', {
                        p_admin_code: adminCode,
                        p_img_url: imgUrl
                    });

                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showHeroMsg(data?.error || 'Failed to add slide', true);
                        return;
                    }

                    showHeroMsg('Slide added! Visitors will see it on page refresh.', false);
                    hEl.form.reset();
                    heroConvertedUrl = null;
                    setHidden(hEl.urlStatus, true);
                    setHidden(hEl.preview, true);
                    loadHeroItems();
                } catch (err) {
                    showHeroMsg('Error: ' + err.message, true);
                } finally {
                    hEl.addBtn.disabled = false;
                    hEl.addBtn.textContent = 'Add Slide';
                }
            });

            // ----- Load Hero Items -----
            async function loadHeroItems() {
                if (!db || !adminCode) return;

                try {
                    const { data, error } = await db.rpc('admin_list_hero_slides', {
                        p_admin_code: adminCode
                    });

                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        hEl.list.textContent = '';
                        const p = document.createElement('p');
                        p.className = 'text-danger';
                        p.style.fontSize = '0.85rem';
                        p.textContent = String(data?.error || 'Failed to load');
                        hEl.list.appendChild(p);
                        return;
                    }

                    heroItems = data.items || [];
                    renderHeroItems();
                    heroLoaded = true;
                } catch (err) {
                    hEl.list.textContent = '';
                    const p = document.createElement('p');
                    p.className = 'text-danger';
                    p.style.fontSize = '0.85rem';
                    p.textContent = 'Error: ' + String(err?.message || err || 'Unknown error');
                    hEl.list.appendChild(p);
                }
            }

            // ----- Render Hero Items -----
            function renderHeroItems() {
                const active = heroItems.filter(i => i.is_active).length;
                const total = heroItems.length;
                hEl.count.textContent = `${active} active / ${total} total slides`;

                if (total === 0) {
                    hEl.list.textContent = '';
                    const p = document.createElement('p');
                    p.className = 'text-muted-2';
                    p.style.fontSize = '0.85rem';
                    p.textContent = 'No hero slides yet. Add your first slide above!';
                    hEl.list.appendChild(p);
                    return;
                }

                hEl.list.textContent = '';
                const fragment = document.createDocumentFragment();

                for (const item of heroItems) {
                    const isActive = Boolean(item.is_active);
                    const date = new Date(item.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    const flashClass = String(item.id) === String(heroLastMovedId) ? ' flash' : '';

                    const row = document.createElement('div');
                    row.className = 'gallery-item ' + (isActive ? '' : 'inactive') + flashClass;
                    row.setAttribute('data-hero-id', String(item.id));

                    const handle = document.createElement('span');
                    handle.className = 'drag-handle';
                    handle.title = 'Drag to reorder';
                    handle.textContent = '‚†ø';

                    const thumb = document.createElement('div');
                    thumb.className = 'gallery-item-thumb';
                    if (typeof item.img_url === 'string' && item.img_url.startsWith('http')) {
                        const img = document.createElement('img');
                        img.loading = 'lazy';
                        img.alt = 'Hero slide';
                        img.src = item.img_url;
                        img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                        thumb.appendChild(img);
                    } else {
                        const fallback = document.createElement('span');
                        fallback.style.display = 'flex';
                        fallback.style.alignItems = 'center';
                        fallback.style.justifyContent = 'center';
                        fallback.style.height = '100%';
                        fallback.style.fontSize = '1.2rem';
                        fallback.textContent = 'üñºÔ∏è';
                        thumb.appendChild(fallback);
                    }

                    const info = document.createElement('div');
                    info.className = 'gallery-item-info';
                    const title = document.createElement('div');
                    title.className = 'gallery-item-title';
                    // Truncate the URL for display
                    const shortUrl = item.img_url.length > 50 ? item.img_url.substring(0, 50) + '‚Ä¶' : item.img_url;
                    title.textContent = shortUrl;
                    title.title = item.img_url;
                    const meta = document.createElement('div');
                    meta.className = 'gallery-item-meta';
                    meta.textContent = 'Added ' + date;
                    info.append(title, meta);

                    const sortInput = document.createElement('input');
                    sortInput.type = 'number';
                    sortInput.className = 'gallery-sort-input';
                    sortInput.min = '1';
                    sortInput.max = '9999';
                    sortInput.title = 'Position (1 = first)';
                    sortInput.setAttribute('data-hero-action', 'sort');
                    sortInput.setAttribute('data-hero-id', String(item.id));
                    sortInput.setAttribute('aria-label', 'Sort order for hero slide');
                    const safeSort = Number.isFinite(Number(item.sort_order)) ? Math.max(1, Number(item.sort_order)) : 1;
                    sortInput.value = String(safeSort);

                    const actions = document.createElement('div');
                    actions.className = 'gallery-item-actions';

                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'mini-btn gallery-item-badge ' + (isActive ? 'active' : 'hidden');
                    toggleBtn.setAttribute('role', 'switch');
                    toggleBtn.setAttribute('aria-checked', String(isActive));
                    toggleBtn.setAttribute('data-hero-action', 'toggle');
                    toggleBtn.setAttribute('data-hero-id', String(item.id));
                    toggleBtn.title = 'Click to ' + (isActive ? 'hide' : 'show');
                    toggleBtn.textContent = isActive ? 'üëÅÔ∏è' : 'üö´';

                    const editBtn = document.createElement('button');
                    editBtn.className = 'mini-btn secondary';
                    editBtn.setAttribute('data-hero-action', 'edit');
                    editBtn.setAttribute('data-hero-id', String(item.id));
                    editBtn.title = 'Edit URL';
                    editBtn.textContent = '‚úèÔ∏è';

                    const delBtn = document.createElement('button');
                    delBtn.className = 'mini-btn danger';
                    delBtn.setAttribute('data-hero-action', 'delete');
                    delBtn.setAttribute('data-hero-id', String(item.id));
                    delBtn.title = 'Delete permanently';
                    delBtn.textContent = 'üóëÔ∏è';

                    actions.append(toggleBtn, editBtn, delBtn);
                    row.append(handle, thumb, info, sortInput, actions);
                    fragment.appendChild(row);
                }

                hEl.list.appendChild(fragment);

                if (heroLastMovedId !== null) {
                    setTimeout(() => { heroLastMovedId = null; }, 0);
                }
            }

            // ----- Toggle Hero Slide -----
            async function toggleHeroSlide(id, btn) {
                if (!db || !adminCode) return;
                btn.disabled = true;
                try {
                    const { data, error } = await db.rpc('admin_toggle_hero_slide', {
                        p_admin_code: adminCode,
                        p_slide_id: parseInt(id, 10)
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showHeroMsg(data?.error || 'Toggle failed', true);
                        return;
                    }
                    showHeroMsg(data.is_active ? 'Slide is now visible' : 'Slide hidden from visitors', false);
                    loadHeroItems();
                } catch (err) {
                    showHeroMsg('Error: ' + err.message, true);
                } finally {
                    btn.disabled = false;
                }
            }

            // ----- Delete Hero Slide (double-click to confirm) -----
            async function deleteHeroSlide(id, btn) {
                if (!heroDeletePending.has(id)) {
                    heroDeletePending.set(id, true);
                    btn.textContent = '‚ö†Ô∏è Sure?';
                    btn.classList.remove('danger');
                    btn.classList.add('confirm-armed');
                    setTimeout(() => {
                        if (heroDeletePending.has(id)) {
                            heroDeletePending.delete(id);
                            btn.textContent = 'üóëÔ∏è';
                            btn.classList.remove('confirm-armed');
                            btn.classList.add('danger');
                        }
                    }, HERO_DELETE_MS);
                    return;
                }

                heroDeletePending.delete(id);
                btn.disabled = true;
                btn.textContent = '...';

                try {
                    const { data, error } = await db.rpc('admin_delete_hero_slide', {
                        p_admin_code: adminCode,
                        p_slide_id: parseInt(id, 10)
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showHeroMsg(data?.error || 'Delete failed', true);
                        return;
                    }
                    showHeroMsg('Slide deleted permanently', false);
                    loadHeroItems();
                } catch (err) {
                    showHeroMsg('Error: ' + err.message, true);
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üóëÔ∏è';
                    btn.classList.remove('confirm-armed');
                    btn.classList.add('danger');
                }
            }

            // ----- Edit Hero Slide (inline URL edit modal) -----
            let heroEditOverlay = null;
            let heroEditConvertedUrl = null;
            let heroEditEscHandler = null;

            function openHeroEditModal(id) {
                const item = heroItems.find(i => String(i.id) === String(id));
                if (!item) return;

                if (heroEditOverlay) heroEditOverlay.remove();
                heroEditConvertedUrl = null;

                heroEditOverlay = document.createElement('div');
                heroEditOverlay.className = 'gallery-edit-overlay';
                heroEditOverlay.innerHTML = `
                    <div class="gallery-edit-modal">
                        <h3>‚úèÔ∏è Edit Slide URL</h3>
                        <div id="heroEditMessage" class="gallery-edit-message is-hidden"></div>
                        <div class="gallery-edit-preview">
                            <div class="gallery-edit-preview-img" id="heroEditPreviewImg"></div>
                            <div class="gallery-edit-preview-text">
                                <div style="font-weight:600;font-size:0.9rem;color:var(--color-text);" id="heroEditPreviewCaption">Hero Slide</div>
                                <div class="gallery-edit-preview-caption" id="heroEditPreviewSubtext"></div>
                            </div>
                        </div>
                        <form class="gallery-form" id="heroEditForm">
                            <label for="heroEditUrl">Image URL</label>
                            <input type="text" id="heroEditUrl" placeholder="Paste Google Drive share link or direct image URL" required>
                            <div id="heroEditUrlStatus" class="gallery-url-status is-hidden"></div>
                            <div class="gallery-edit-actions">
                                <button type="button" class="gallery-edit-cancel" id="heroEditCancelBtn">Cancel</button>
                                <button type="submit" class="gallery-add-btn" id="heroEditSaveBtn">Save Changes</button>
                            </div>
                        </form>
                    </div>
                `;

                document.body.appendChild(heroEditOverlay);

                const urlInput = heroEditOverlay.querySelector('#heroEditUrl');
                const urlStatus = heroEditOverlay.querySelector('#heroEditUrlStatus');
                const previewImg = heroEditOverlay.querySelector('#heroEditPreviewImg');
                const previewSubtext = heroEditOverlay.querySelector('#heroEditPreviewSubtext');
                const editMessage = heroEditOverlay.querySelector('#heroEditMessage');

                urlInput.value = String(item.img_url || '');
                previewSubtext.textContent = item.is_active ? '‚úÖ Visible on site' : 'üö´ Hidden from site';

                // Set preview image
                previewImg.textContent = '';
                if (typeof item.img_url === 'string' && item.img_url.startsWith('http')) {
                    const img = document.createElement('img');
                    img.alt = 'Current slide';
                    img.src = item.img_url;
                    img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                    previewImg.appendChild(img);
                }

                function handleHeroEditUrlInput() {
                    const raw = urlInput.value.trim();
                    if (!raw) {
                        urlStatus.classList.add('is-hidden');
                        heroEditConvertedUrl = null;
                        return;
                    }
                    const fileId = heroExtractDriveFileId(raw);
                    if (fileId) {
                        const embedUrl = heroToEmbedUrl(fileId);
                        heroEditConvertedUrl = embedUrl;
                        urlStatus.textContent = '‚úÖ Google Drive link converted';
                        urlStatus.className = 'gallery-url-status valid';
                        previewImg.textContent = '';
                        const img = document.createElement('img');
                        img.alt = 'Preview';
                        img.src = embedUrl;
                        img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                        previewImg.appendChild(img);
                    } else {
                        heroEditConvertedUrl = null;
                        if (raw.startsWith('http')) {
                            urlStatus.textContent = '‚úÖ Direct URL detected';
                            urlStatus.className = 'gallery-url-status valid';
                            previewImg.textContent = '';
                            const img = document.createElement('img');
                            img.alt = 'Preview';
                            img.src = raw;
                            img.addEventListener('error', () => { img.style.display = 'none'; }, { once: true });
                            previewImg.appendChild(img);
                        } else {
                            urlStatus.textContent = '‚ö†Ô∏è Invalid URL format';
                            urlStatus.className = 'gallery-url-status invalid';
                        }
                    }
                }

                urlInput.addEventListener('input', handleHeroEditUrlInput);
                urlInput.addEventListener('paste', () => setTimeout(handleHeroEditUrlInput, 50));

                urlInput.focus();
                urlInput.select();

                heroEditOverlay.addEventListener('click', (ev) => {
                    if (ev.target === heroEditOverlay) closeHeroEditModal();
                });
                heroEditOverlay.querySelector('#heroEditCancelBtn').addEventListener('click', closeHeroEditModal);

                // Focus trap
                const modal = heroEditOverlay.querySelector('.gallery-edit-modal');
                modal.addEventListener('keydown', (ev) => {
                    if (ev.key !== 'Tab') return;
                    const focusable = modal.querySelectorAll(
                        'input:not([disabled]), button:not([disabled]), [tabindex]:not([tabindex="-1"])'
                    );
                    if (!focusable.length) return;
                    const first = focusable[0];
                    const last = focusable[focusable.length - 1];
                    if (ev.shiftKey && document.activeElement === first) {
                        ev.preventDefault();
                        last.focus();
                    } else if (!ev.shiftKey && document.activeElement === last) {
                        ev.preventDefault();
                        first.focus();
                    }
                });

                if (heroEditEscHandler) {
                    document.removeEventListener('keydown', heroEditEscHandler);
                }
                heroEditEscHandler = (ev) => {
                    if (ev.key === 'Escape') closeHeroEditModal();
                };
                document.addEventListener('keydown', heroEditEscHandler);

                function showHeroEditMessage(text, isError) {
                    editMessage.textContent = text;
                    editMessage.className = isError ? 'gallery-edit-message error' : 'gallery-edit-message success';
                    editMessage.classList.remove('is-hidden');
                    setTimeout(() => editMessage.classList.add('is-hidden'), 4000);
                }

                heroEditOverlay.querySelector('#heroEditForm').addEventListener('submit', async (ev) => {
                    ev.preventDefault();
                    const newUrl = heroEditConvertedUrl || urlInput.value.trim();
                    if (!newUrl) { showHeroEditMessage('Image URL is required.', true); return; }

                    const saveBtn = heroEditOverlay.querySelector('#heroEditSaveBtn');
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';

                    try {
                        const { data, error } = await db.rpc('admin_edit_hero_slide', {
                            p_admin_code: adminCode,
                            p_slide_id: parseInt(id, 10),
                            p_img_url: newUrl
                        });
                        if (error) throw new Error(error.message);
                        if (!data || !data.success) {
                            showHeroEditMessage(data?.error || 'Update failed', true);
                            saveBtn.disabled = false;
                            saveBtn.textContent = 'Save Changes';
                            return;
                        }
                        showHeroEditMessage('‚úÖ Slide updated!', false);
                        setTimeout(() => {
                            closeHeroEditModal();
                            loadHeroItems();
                        }, 1000);
                    } catch (err) {
                        showHeroEditMessage('Error: ' + err.message, true);
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'Save Changes';
                    }
                });
            }

            function closeHeroEditModal() {
                if (heroEditEscHandler) {
                    document.removeEventListener('keydown', heroEditEscHandler);
                    heroEditEscHandler = null;
                }
                if (heroEditOverlay) {
                    heroEditOverlay.remove();
                    heroEditOverlay = null;
                }
            }

            // ----- Event Delegation for Hero List -----
            hEl.list.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (!btn) return;
                const action = btn.getAttribute('data-hero-action');
                const id = btn.getAttribute('data-hero-id');
                if (!action || !id) return;

                if (action === 'toggle') toggleHeroSlide(id, btn);
                if (action === 'edit') openHeroEditModal(id);
                if (action === 'delete') deleteHeroSlide(id, btn);
            });

            // ----- Quiet Background Sync -----
            async function heroSyncSortOrders() {
                if (!db || !adminCode) return;
                try {
                    const { data, error } = await db.rpc('admin_list_hero_slides', {
                        p_admin_code: adminCode
                    });
                    if (error || !data || !data.success) return;
                    const serverItems = data.items || [];
                    const serverMap = new Map(serverItems.map(i => [String(i.id), i]));
                    heroItems.forEach(item => {
                        const server = serverMap.get(String(item.id));
                        if (server) item.sort_order = server.sort_order;
                    });
                    heroItems.sort((a, b) => a.sort_order - b.sort_order);
                    heroItems.forEach(item => {
                        const input = hEl.list.querySelector(`input.gallery-sort-input[data-hero-id="${item.id}"]`);
                        if (input) input.value = item.sort_order;
                    });
                } catch (_) { /* best-effort */ }
            }

            // ----- Inline Sort-Order Save -----
            async function heroSaveSortOrder(input) {
                const id = input.getAttribute('data-hero-id');
                const item = heroItems.find(i => String(i.id) === String(id));
                if (!item) return;
                let newVal = parseInt(input.value, 10);
                if (isNaN(newVal) || newVal < 1) {
                    input.value = Math.max(1, item.sort_order);
                    return;
                }
                if (newVal === item.sort_order) return;

                input.disabled = true;
                try {
                    const { data, error } = await db.rpc('admin_reorder_hero_slide', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(id, 10),
                        p_new_sort_order: newVal
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) { showHeroMsg(data?.error || 'Sort update failed', true); return; }
                    showHeroMsg(`Position updated to ${newVal}`, false);
                    loadHeroItems();
                } catch (err) {
                    showHeroMsg('Error: ' + err.message, true);
                } finally {
                    input.disabled = false;
                }
            }

            hEl.list.addEventListener('change', (e) => {
                if (e.target.matches('.gallery-sort-input[data-hero-action="sort"]')) heroSaveSortOrder(e.target);
            });
            hEl.list.addEventListener('keydown', (e) => {
                if (e.target.matches('.gallery-sort-input[data-hero-action="sort"]') && e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });

            // ----- Drag & Drop Reorder (Desktop + Touch) -----
            let heroDragSrcId = null;
            let heroCurrentDropTarget = null;

            function heroClearDropIndicators() {
                if (!hEl.list) return;
                hEl.list.querySelectorAll('.drag-over, .drop-before, .drop-after').forEach(el => {
                    el.classList.remove('drag-over', 'drop-before', 'drop-after');
                });
                heroCurrentDropTarget = null;
            }

            function heroUpdateDropIndicator(row, clientY) {
                if (!row || row.getAttribute('data-hero-id') === heroDragSrcId) {
                    if (heroCurrentDropTarget) {
                        heroCurrentDropTarget.classList.remove('drag-over', 'drop-before', 'drop-after');
                        heroCurrentDropTarget = null;
                    }
                    heroDragDropTarget.id = null;
                    return;
                }
                const rect = row.getBoundingClientRect();
                const isBefore = (clientY - rect.top) < rect.height / 2;

                if (heroCurrentDropTarget && heroCurrentDropTarget !== row) {
                    heroCurrentDropTarget.classList.remove('drag-over', 'drop-before', 'drop-after');
                }
                heroCurrentDropTarget = row;
                row.classList.remove('drop-before', 'drop-after');
                row.classList.add('drag-over', isBefore ? 'drop-before' : 'drop-after');

                heroDragDropTarget.id = row.getAttribute('data-hero-id');
                heroDragDropTarget.position = isBefore ? 'before' : 'after';
            }

            function heroOptimisticReorder(srcId, tgtId, position) {
                const srcEl = hEl.list.querySelector(`[data-hero-id="${srcId}"]`);
                const tgtEl = hEl.list.querySelector(`[data-hero-id="${tgtId}"]`);
                if (!srcEl || !tgtEl) return;

                if (position === 'before') {
                    tgtEl.parentNode.insertBefore(srcEl, tgtEl);
                } else {
                    tgtEl.parentNode.insertBefore(srcEl, tgtEl.nextSibling);
                }

                srcEl.classList.add('dropped');
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => srcEl.classList.remove('dropped'));
                });

                const srcIdx = heroItems.findIndex(i => String(i.id) === String(srcId));
                const tgtIdx = heroItems.findIndex(i => String(i.id) === String(tgtId));
                if (srcIdx !== -1 && tgtIdx !== -1) {
                    const [moved] = heroItems.splice(srcIdx, 1);
                    const newTgtIdx = heroItems.findIndex(i => String(i.id) === String(tgtId));
                    if (newTgtIdx !== -1) {
                        const insertAt = position === 'before' ? newTgtIdx : newTgtIdx + 1;
                        heroItems.splice(insertAt, 0, moved);
                    }
                    heroItems.forEach((item, i) => { item.sort_order = i + 1; });
                    heroItems.forEach(item => {
                        const input = hEl.list.querySelector(`input.gallery-sort-input[data-hero-id="${item.id}"]`);
                        if (input) input.value = item.sort_order;
                    });
                }
            }

            async function heroPerformDrop() {
                const targetId = heroDragDropTarget.id;
                const targetPosition = heroDragDropTarget.position || 'before';
                heroClearDropIndicators();

                if (!heroDragSrcId || !targetId || heroDragSrcId === targetId) return;

                const snapshot = heroItems.map(i => ({ ...i }));
                heroOptimisticReorder(heroDragSrcId, targetId, targetPosition);

                try {
                    const { data, error } = await db.rpc('admin_move_hero_slide', {
                        p_admin_code: adminCode,
                        p_item_id: parseInt(heroDragSrcId, 10),
                        p_target_id: parseInt(targetId, 10),
                        p_position: targetPosition
                    });
                    if (error) throw new Error(error.message);
                    if (!data || !data.success) {
                        showHeroMsg(data?.error || 'Move failed ‚Äî reverting', true);
                        heroItems = snapshot;
                        renderHeroItems();
                        return;
                    }
                    heroSyncSortOrders();
                } catch (err) {
                    showHeroMsg('Error: ' + (err?.message || err) + ' ‚Äî reverting', true);
                    heroItems = snapshot;
                    renderHeroItems();
                }
            }

            // ‚Äî‚Äî‚Äî Shared pointer drag (mouse + touch) ‚Äî‚Äî‚Äî
            let heroDragClone = null;
            let heroDragSourceRow = null;
            let heroDragOffsetY = 0;

            function heroStartDrag(row, clientX, clientY) {
                const sel = window.getSelection();
                if (sel) sel.removeAllRanges();

                heroDragSrcId = row.getAttribute('data-hero-id');
                heroDragSourceRow = row;
                row.classList.add('dragging');
                document.body.classList.add('is-dragging');

                const rect = row.getBoundingClientRect();
                heroDragOffsetY = clientY - rect.top;
                heroDragClone = row.cloneNode(true);
                heroDragClone.style.cssText =
                    'position:fixed;pointer-events:none;z-index:10000;transition:none;' +
                    'transform:scale(0.97);opacity:0.88;' +
                    'box-shadow:0 8px 25px rgba(0,0,0,0.18);border-radius:8px;' +
                    'width:' + rect.width + 'px;' +
                    'left:' + rect.left + 'px;' +
                    'top:' + rect.top + 'px;';
                document.body.appendChild(heroDragClone);
            }

            function heroMoveDrag(clientX, clientY) {
                if (heroDragClone) {
                    heroDragClone.style.top = (clientY - heroDragOffsetY) + 'px';
                }
                if (heroDragSourceRow) heroDragSourceRow.style.pointerEvents = 'none';
                const elBelow = document.elementFromPoint(clientX, clientY);
                if (heroDragSourceRow) heroDragSourceRow.style.pointerEvents = '';
                const row = elBelow ? elBelow.closest('[data-hero-id]') : null;
                heroUpdateDropIndicator(row, clientY);
            }

            async function heroEndDrag() {
                if (heroDragSourceRow) heroDragSourceRow.classList.remove('dragging');
                if (heroDragClone) { heroDragClone.remove(); heroDragClone = null; }
                document.body.classList.remove('is-dragging');

                await heroPerformDrop();

                heroDragSourceRow = null;
                heroDragSrcId = null;
                heroDragDropTarget.id = null;
                heroDragDropTarget.position = 'before';
            }

            // ‚Äî‚Äî‚Äî Mouse events (desktop) ‚Äî‚Äî‚Äî
            hEl.list.addEventListener('mousedown', (e) => {
                const handle = e.target.closest('.drag-handle');
                if (!handle) return;
                const row = handle.closest('[data-hero-id]');
                if (!row) return;
                e.preventDefault();

                heroStartDrag(row, e.clientX, e.clientY);

                function onMouseMove(ev) {
                    ev.preventDefault();
                    heroMoveDrag(ev.clientX, ev.clientY);
                }

                async function onMouseUp() {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    await heroEndDrag();
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });

            hEl.list.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });

            // ‚Äî‚Äî‚Äî Touch events (mobile / tablet) ‚Äî‚Äî‚Äî
            hEl.list.addEventListener('touchstart', (e) => {
                const handle = e.target.closest('.drag-handle');
                if (!handle) return;
                const row = handle.closest('[data-hero-id]');
                if (!row) return;

                const touch = e.touches[0];
                heroStartDrag(row, touch.clientX, touch.clientY);
            }, { passive: true });

            hEl.list.addEventListener('touchmove', (e) => {
                if (!heroDragSourceRow) return;
                e.preventDefault();
                const touch = e.touches[0];
                heroMoveDrag(touch.clientX, touch.clientY);
            }, { passive: false });

            hEl.list.addEventListener('touchend', async () => {
                if (!heroDragSourceRow) return;
                await heroEndDrag();
            });

            // ----- Load on section open -----
            hEl.section.addEventListener('toggle', () => {
                if (hEl.section.open && !heroLoaded && db && adminCode) {
                    loadHeroItems();
                }
            });
        }

        // Event Delegation for generated links
        if (elements.recentLinksList) {
            elements.recentLinksList.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (!btn) return;

                const action = btn.getAttribute('data-action');
                if (!action) return;

                if (action === 'copy') {
                    const link = btn.getAttribute('data-link');
                    if (link) copyLinkToClipboard(link);
                } else if (action === 'test') {
                    const link = btn.getAttribute('data-link');
                    Trace.log('USER_TEST_CLICK', { link });
                    if (link) openLink(link);
                } else if (action === 'delete') {
                    const id = btn.getAttribute('data-id');
                    if (id) deleteToken(id, btn);
                } else if (action === 'filter') {
                    const source = btn.getAttribute('data-source');
                    Trace.log('USER_FILTER_CLICK', { source });
                    if (source) filterBySource(source);
                }
            });

            elements.recentLinksList.addEventListener('dblclick', (e) => {
                const field = e.target.closest('.link-item-url-field');
                if (!field) return;
                field.focus();
                field.select();
                Trace.log('USER_URL_DBLCLICK', { url: field.value });
            });
        }


    })();
    </script>
</body>
</html>